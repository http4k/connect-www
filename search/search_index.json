{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"changelog/","title":"Changelog","text":"<p>This list is not intended to be all-encompassing - it will document major and breaking API  changes with their rationale when appropriate. Given version <code>A.B.C.D</code>, breaking changes are to be expected in version number increments where changes in the <code>A</code> or <code>B</code> sections:</p>"},{"location":"changelog/#v52410","title":"v5.24.1.0","text":"<ul> <li>http4k-connect-ai- - Chat completion API tightening</li> </ul>"},{"location":"changelog/#v52400","title":"v5.24.0.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies including</li> <li>http4k-connect-ai-openai* - [Breaking] Tightened up types for completion requests. </li> <li>http4k-connect-ai-azure* - [Breaking] Tightened up types for completion requests. </li> <li>http4k-connect-ai-lmstudio* - [Breaking] Tightened up types for completion requests. </li> <li>http4k-connect-ai-ollama* - [Breaking] Tightened up types for completion requests. </li> </ul>"},{"location":"changelog/#v52300","title":"v5.23.0.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies including Kotlin to 2.0.20</li> <li>http4k-connect-ai-azure* - Add new operations.</li> <li>http4k-connect-ai-anthropic* - [New Module] Support for Anthropic AI inference.</li> </ul>"},{"location":"changelog/#v52200","title":"v5.22.0.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> <li>http4k-connect-* - [Deprecations] Moved some shared types to the core module.</li> <li>http4k-connect-ai-* - [Breaking] Shared types have been moved to ai-core. Role.user -&gt; Role.Companion.User</li> <li>http4k-connect-ai-azure* - [New Module] Support for Azure AI inference, and GitHub Models support for prototyping.</li> </ul>"},{"location":"changelog/#v52100","title":"v5.21.0.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies including Kotlin to 2.0.10</li> <li>http4k-connect-core - [Deprecation] Rename of <code>Http4kConnectAdapter</code> to <code>Http4kConnectClient</code></li> <li>http4k-connect-ai-openai-** - [Breaking] Model ResponseFormat as a sealed class hierarchy. Removed ResponseFormatType as now inherent in the JSON marshalling. Alpha support for <code>json_schema</code> response format, but it's just a map right now with no class structure.</li> </ul>"},{"location":"changelog/#v52000","title":"v5.20.0.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies, including Kotshi to 3.0.0. Version bump to highlight that this could be a breaking change if you are using the Kotshi annotation processor.</li> <li>http4k-connect-amazon-s3=* - Add CommonPrefixes field to S3 ListObjectsV2 response. H/T @kwydler</li> </ul>"},{"location":"changelog/#v51902","title":"v5.19.0.2","text":"<ul> <li>http4k-connect-* - [Fix] Add missing @JsonSerializable annotation to ReceiveMessage action</li> </ul>"},{"location":"changelog/#v51901","title":"v5.19.0.1","text":"<ul> <li>http4k-connect-* - [Fix] Add missing Kotshi adapter to Core Moshi adapter factory.</li> </ul>"},{"location":"changelog/#v51900","title":"v5.19.0.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> <li>http4k-connect-* - [Breaking] http4k has introduced a breaking change in 5.26.0.0. If you are using the typesafe   configuration environment, you will need to update your code to use the repackaged <code>Environment</code> classes - these are   now in <code>org.http4k.config</code> instead of <code>org.http4k.cloudnative.env</code>. Just updating your imports should be sufficient to   fix this.</li> </ul>"},{"location":"changelog/#v51800","title":"v5.18.0.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> <li>http4k-connect-amazon-cognito* - [Breaking] AWS Cognito: Add support for server side authentication (   AdminInitiateAuth and AdminRespondToAuthChallenge). H/T @markth0mas</li> <li>http4k-connect-ai-** - [Breaking] Repackaged <code>ModelName</code> to common location. Just update imports!</li> <li>http4k-connect-ai-langchain -  [Breaking] Added support for LmStudio chat and embedding models. Break is   renamed: <code>ChatModelOptions</code> to <code>OpenAiChatModelOptions</code>.</li> <li>http4k-connect-ai-lmstudio* - [New module!] LmStudio client module and fake so you can connect to a locally   running LLM server running any model.</li> </ul>"},{"location":"changelog/#v51711","title":"v5.17.1.1","text":"<ul> <li>http4k-connect-amazon-sqs-* - [Fix] Type of SQS ReceiveMessage waitTimeSeconds parameter was incorrect. H/T @oharaandrew314</li> </ul>"},{"location":"changelog/#v51710","title":"v5.17.1.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> <li>http4k-connect-amazon-s3-* - Support all storage classes, including the restore lifecycle for glacier. H/T @oharaandrew314</li> <li>http4k-connect-amazon-s3-* - Support S3 object tagging. H/T @oharaandrew314</li> </ul>"},{"location":"changelog/#v51702","title":"v5.17.0.2","text":"<ul> <li>http4k-connect-ai-openai - Choices are not optional in conversation completion.</li> <li>http4k-connect-ai-langchain - Fix streaming for OpenAiChatLanguageModel. </li> </ul>"},{"location":"changelog/#v51701","title":"v5.17.0.1","text":"<ul> <li>http4k-connect-ai-langchain - Added support for System messages in Ollama models</li> </ul>"},{"location":"changelog/#v51700","title":"v5.17.0.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> <li>http4k-connect-ai-* - Migration of the various AI packages (OpenAI/Langchain) to <code>http4k-ai-</code> subpackage name. </li> <li>http4k-connect-ai-openai - [Breaking] Use FloatArray for embeddings instead of <code>List&lt;Float&gt;</code></li> <li>http4k-connect-ai-ollama* - [New module!] Ollama client module so you can use Http4k-connect clients in   LangChain apps.</li> <li>http4k-connect-ai-langchain - Added support for Ollama models</li> </ul>"},{"location":"changelog/#v51602","title":"v5.16.0.2","text":"<ul> <li>http4k-connect-ai-langchain - Properly support all message types in OpenAI Client.</li> </ul>"},{"location":"changelog/#v51601","title":"v5.16.0.1","text":"<ul> <li>http4k-connect-langchain - Tools requests cannot be empty for chat completions in OpenAI Client.</li> </ul>"},{"location":"changelog/#v51600","title":"v5.16.0.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> <li>http4k-connect-langchain - [New module!] LangChain adapter module so you can use Http4k-connect clients in LangChain apps. Currently only OpenAI is supported.</li> <li>http4k-connect-openai-* - [Breaking] Support tool calls and more modern API version for ChatCompletion.</li> </ul>"},{"location":"changelog/#v51500","title":"v5.15.0.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> <li>http4k-connect-amazon-sqs- - [Possible break] Implement JSON version of SQS in both fake and client. Ensure you are using an up-to-date version of the AWS SDK (which will support the JSON message format). Massive H/T @oharaandrew314</li> </ul>"},{"location":"changelog/#v51400","title":"v5.14.0.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies, including Kotlin to V2!</li> </ul>"},{"location":"changelog/#v51300","title":"v5.13.0.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies, including Kotlin to 1.9.24</li> <li>http4k-connect-amazon-dynamodb* - Add StreamsEventResponse model. H/T @charlee-dev</li> <li>http4k-connect-evidently* - [Fix #405] Properly parse evidently project and features names from ARN. H/T @oharaandrew314</li> </ul>"},{"location":"changelog/#v51220","title":"v5.12.2.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies</li> </ul>"},{"location":"changelog/#v51210","title":"v5.12.1.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies</li> </ul>"},{"location":"changelog/#v51200","title":"v5.12.0.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies, and api changes to support new http4k version.</li> </ul>"},{"location":"changelog/#v51100","title":"v5.11.0.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies</li> <li>http4k-connect-* - [Breaking] Reordering of the parameters in client constructors to put <code>overrideEndpoint</code> at the end of the list, since it is the least commonly used. To fix, just reorder your parameters.</li> </ul>"},{"location":"changelog/#v51010","title":"v5.10.1.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies</li> <li>http4k-connect-amazon-dynamodb* - Align secondary index constructors in DynamoDbTableMapperSchema. H/T @obecker</li> <li>http4k-connect-amazon-dynamodb-fake - Validate reserved words in DynamoDB condition expressions. H/T @oharaandrew314</li> </ul>"},{"location":"changelog/#v51000","title":"v5.10.0.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies</li> <li>http4k-connect-amazon-dynamodb - [Breaking] <code>DynamoDbIndexMapper</code> now supports custom projections. Closes #391. H/T @oharaandrew314</li> </ul>"},{"location":"changelog/#v5900","title":"v5.9.0.0","text":"<ul> <li>http4k-connect-amazon-dynamodb - [Breaking] <code>keyCondition</code> in query DSL no longer accepts arbitrary attributes. Fixes #380. H/T @obecker</li> </ul>"},{"location":"changelog/#v5800","title":"v5.8.0.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies, including Kotlin to 1.9.23</li> <li>http4k-connect-amazon-dynamodb - [Breaking] <code>ExclusiveStartKey</code> in <code>DynamoDbIndexMapper</code> functions is now an unconstrained <code>Key</code>. Fixes #372. H/T @oharaandrew314</li> </ul>"},{"location":"changelog/#v5700","title":"v5.7.0.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> <li>http4k-connect-amazon-dynamodb - Query builder for DynamoDB. H/T @obecker</li> <li>http4k-connect-amazon-dynamodb - [Breaking] <code>Query</code> and <code>Scan</code> <code>Select</code> field is enum instead of String. To fix, just replace the hardcoded string with the enum! H/T @obecker</li> <li>http4k-connect-amazon-kms - Support for KeySpec property. H/T @oharaandrew314</li> </ul>"},{"location":"changelog/#v56150","title":"v5.6.15.0","text":"<ul> <li>http4k-connect-storage-* StoragePropertyBag allows storage-backed dynamic backing Read/WriteProperties. Extend <code>StoragePropertyBag</code> and declare typed properties with <code>item&lt;TYPE&gt;()</code>. Properties are stored into the backing storage using standard automarshalling. </li> </ul>"},{"location":"changelog/#v56140","title":"v5.6.14.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> <li>http4k-connect-* - Add optional endpoint parameter to all AWS service HTTP implementations. H/T @obecker</li> </ul>"},{"location":"changelog/#v56130","title":"v5.6.13.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> </ul>"},{"location":"changelog/#v56120","title":"v5.6.12.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> </ul>"},{"location":"changelog/#v56110","title":"v5.6.11.0","text":"<ul> <li>http4k-connect-amazon-core - SSO credentials provider now caches credentials until they expire. Stops re-login</li> </ul>"},{"location":"changelog/#v56100","title":"v5.6.10.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> <li>http4k-connect-amazon-core - Simpler API for retrieving the AWS credentials of a custom profile. H/T @obecker</li> <li>http4k-connect-amazon-s3* - Add parameter to force path-style requests to S3 buckets. H/T @obecker</li> </ul>"},{"location":"changelog/#v5690","title":"v5.6.9.0","text":"<ul> <li>http4k-connect-amazon-apprunner* - [New module] Client and fake</li> </ul>"},{"location":"changelog/#v5682","title":"v5.6.8.2","text":"<ul> <li>http4k-connect-amazon-containercredentials* - Add Kotshi adapter to Moshi instance.</li> </ul>"},{"location":"changelog/#v5681","title":"v5.6.8.1","text":"<ul> <li>http4k-connect-* - Fix AutoMarshalledPageAction not recognising arrays with whitespace.</li> </ul>"},{"location":"changelog/#v5680","title":"v5.6.8.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> </ul>"},{"location":"changelog/#v5670","title":"v5.6.7.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> <li>http4k-connect-amazon-eventbridge* Events can be sent with the ARN and not just with the EventBusName</li> </ul>"},{"location":"changelog/#v5660","title":"v5.6.6.0","text":"<ul> <li>http4k-connect-amazon-dynamodb-client* - [Fix] #344 Handle failures in <code>DynamoDbTableMapper.delete()</code> H/T @obecker</li> <li>http4k-connect-amazon-evidently* Add <code>updateFeature</code> to Evidently.  H/T @oharaandrew314</li> </ul>"},{"location":"changelog/#v5650","title":"v5.6.5.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> <li>http4k-connect-* - Fix <code>AutomarshalledPagedAction</code> so that it deals with pages of results which do not get returned inside a list but in an object wrapping a list.</li> </ul>"},{"location":"changelog/#v5640","title":"v5.6.4.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> <li>http4k-connect-amazon-** - Added Amazon Presigner for creating pre-signed requests. H/T @oharaandrew314</li> <li>http4k-connect-amazon-dynamodb-fake* - [Fix] #327 Query algorithm is slight wrong in fake dynamo. H/T @oharaandrew314</li> </ul>"},{"location":"changelog/#v5630","title":"v5.6.3.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> <li>http4k-connect-amazon-systemsmanager-fake* - [Fix] #339 - Fake Systems Manager does not overwrite parameters - returns 400</li> </ul>"},{"location":"changelog/#v5620","title":"v5.6.2.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> </ul>"},{"location":"changelog/#v5610","title":"v5.6.1.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> </ul>"},{"location":"changelog/#v5600","title":"v5.6.0.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies, including Kotlin to 1.9.21</li> <li>http4k-connect-amazon-dynamodb-fake - Add support for sparse indexes. H/T @obecker</li> <li>http4k-connect-openai [Fix] Optional fields in <code>getModels</code> call</li> </ul>"},{"location":"changelog/#v5510","title":"v5.5.1.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies</li> <li>http4k-connect-gitlab - [New module] Basic client module</li> </ul>"},{"location":"changelog/#v5501","title":"v5.5.0.1","text":"<ul> <li>http4k-connect-amazon-eventbridge - Support newline characters inside JSON</li> </ul>"},{"location":"changelog/#v5500","title":"v5.5.0.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies</li> <li>http4k-connect-amazon-iamidentitycenter - [Breaking] Browser infra moved to core. Simple reimport to fix.</li> </ul>"},{"location":"changelog/#v5400","title":"v5.4.0.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies, including Kotlin to 1.9.20.</li> </ul>"},{"location":"changelog/#v5300","title":"v5.3.0.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> <li>http4k-connect-* - [Breaking - dev] http4k-connect is now built with Java 21.</li> <li>http4k-connect-amazon-iamidentitycenter - [New module] Client and fake implementation, plus interactive SSO login via a browser.</li> </ul>"},{"location":"changelog/#v5250","title":"v5.2.5.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> <li>http4k-connect-* - Generated extension functions create defaults for collections types when they are defaulted in the core Action.</li> </ul>"},{"location":"changelog/#v5240","title":"v5.2.4.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> <li>http4k-connect-* - Prevent extra dependencies being published in maven artefacts.</li> </ul>"},{"location":"changelog/#v5230","title":"v5.2.3.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> <li>http4k-connect-amazon-dynamodb-fake Support for TransactWriteItems</li> </ul>"},{"location":"changelog/#v5220","title":"v5.2.2.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> <li>http4k-connect-amazon-dynamodb Present a more concise introduction to the DynamoDB table mapper. H/T @oharaandrew314</li> <li>http4k-connect-amazon-cloudwatchlogs - [New module] Client and fake implementation.</li> </ul>"},{"location":"changelog/#v5200","title":"v5.2.0.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies including Kotlin to 1.9.10.</li> <li>http4k-connect-openai [Breaking change] Added support for Streaming version of ChatCPT completions to both library and fake implementation.</li> <li>http4k-connect-amazon-evidently [New module] Add support for this feature flagging service. H/T @oharaandrew314</li> </ul>"},{"location":"changelog/#v5170","title":"v5.1.7.0","text":"<ul> <li>http4k-connect-amazon-dynamodb-fake Add support for the entire update expression syntax. H/T @oharaandrew314</li> </ul>"},{"location":"changelog/#v5162","title":"v5.1.6.2","text":"<ul> <li>http4k-connect-amazon-eventbridge-fake* - [Fix] Add proper indexing to fake when sending events.</li> </ul>"},{"location":"changelog/#v5161","title":"v5.1.6.1","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> <li>http4k-connect-amazon-firehose* - [Fix] Serialize DeliveryStreamName correctly in Moshi.</li> </ul>"},{"location":"changelog/#v5160","title":"v5.1.6.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> <li>http4k-connect-** - Make generation of IDs more deterministic</li> </ul>"},{"location":"changelog/#v5150","title":"v5.1.5.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> <li>http4k-connect-cognito-** - Add ConfirmForgottenPassword. H/T @dmcg</li> </ul>"},{"location":"changelog/#v5140","title":"v5.1.4.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> <li>http4k-connect-amazon-sqs - Add <code>DeleteMessageBatch</code> action.  H/T @oharaandrew314</li> <li>http4k-connect-amazon-containercredentials - Add container credentials chain @oharaandrew314</li> <li>http4k-connect-amazon-cognito - Moshi config was incorrect for successful user password auth response H/T @time4tea</li> </ul>"},{"location":"changelog/#v5130","title":"v5.1.3.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies, including Kotlin to 1.9.0.</li> <li>http4k-connect-amazon-dynamodb - Add scanPage and queryPage operations to DynamoDb table mapper. Pagination can now be controlled by the caller. H/T @oharaandrew314</li> <li>http4k-connect-amazon-dynamodb-fake - putItem now supports a <code>ConditionExpression</code>.</li> <li>http4k-connect-amazon-dynamodb-fake - [Fix] query and scan will now return the correct LastEvaluatedKey based on the current index. H/T @oharaandrew314</li> <li>http4k-connect-amazon-dynamodb-fake - [Fix] Condition Expressions now support name substitutions in the <code>attribute_exists</code> and <code>attribute_not_exists</code> functions</li> <li>http4k-connect-amazon-containercredentials - [Fix] Handle ARN NOT_SUPPLIED when getting aws credentials and running on AWS AppRunner</li> </ul>"},{"location":"changelog/#v5120","title":"v5.1.2.0","text":"<ul> <li>http4k-connect-amazon-eventbridge - [New module] Client and fake implementation.</li> </ul>"},{"location":"changelog/#v5110","title":"v5.1.1.0","text":"<ul> <li>http4k-connect-amazon-firehose - [New module] Client and fake implementation.</li> </ul>"},{"location":"changelog/#v5100","title":"v5.1.0.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies, including Kotlin to 1.9.0.</li> <li>http4k-connect-amazon-kms-fake - Will now generate unique key pairs for each CMK. H/T @oharaandrew314</li> <li>http4k-connect-amazon-kms-fake - [Fix] Getting the public key for an ECDSA CMK will now work as expected. H/T @oharaandrew314</li> </ul>"},{"location":"changelog/#v5010","title":"v5.0.1.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies</li> </ul>"},{"location":"changelog/#v5000","title":"v5.0.0.0","text":"<ul> <li>http4k-connect* : Upgrade to http4k platform v5 version.</li> <li>http4k-connect* : [Breaking] Remove all previous deprecations from all modules for v4. To upgrade cleanly, first upgrade to <code>v3.43.0.0</code> and then re-upgrade to <code>v5.0.0.0</code>. This will ensure that you only have to deal with Deprecations between the major versions.</li> <li>http4k-connect-kapt-generator : [Breaking] This generator module has been removed due to the replacement of Kapt with KSP. To fix, migrate to use the KSP gradle plugin with the <code>http4k-connect-ksp-generator</code> module instead. There are no more changes required as it is a drop-in replacement.</li> </ul>"},{"location":"changelog/#v34310","title":"v3.43.1.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies</li> <li>http4k-connect-* - [Fix] Code generation for pagination was broken when using AutomarshalledPagedAction</li> </ul>"},{"location":"changelog/#v34300","title":"v3.43.0.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies, including Kotlin to 1.8.22</li> </ul>"},{"location":"changelog/#v34210","title":"v3.42.1.0","text":"<ul> <li>http4k-connect-openai-fake - Support for NoAuth plugin installation.</li> </ul>"},{"location":"changelog/#v34200","title":"v3.42.0.0","text":"<ul> <li>http4k-connect-openai-plugin - [New module] OpenAI plugin development SDK. http4k-connect provides APIs to create plugins for all 3 plugin authorization types - User, Service and OAuth.</li> <li>http4k-connect-openai-fake - Plugins can now be installed into the <code>FakeOpenAI</code> server. All 3 plugin auth types are supported. </li> </ul>"},{"location":"changelog/#v34100","title":"v3.41.0.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> <li>http4k-connect-openai - Properly support OAuth plugin types</li> </ul>"},{"location":"changelog/#v34050","title":"v3.40.5.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> </ul>"},{"location":"changelog/#v34040","title":"v3.40.4.0","text":"<ul> <li>http4k-connect-openai - Small fixes.</li> </ul>"},{"location":"changelog/#v34030","title":"v3.40.3.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> <li>http4k-connect-openai - Add CreateEmbeddings call.</li> </ul>"},{"location":"changelog/#v34020","title":"v3.40.2.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> <li>http4k-connect-amazon-kms-fake* - [Fix] Encryption.decryption works with binary messages</li> </ul>"},{"location":"changelog/#v34012","title":"v3.40.1.2","text":"<ul> <li>http4k-connect-kakfa-rest* - Correct content type and trimming string for producing records to Kafka v3.</li> </ul>"},{"location":"changelog/#v34011","title":"v3.40.1.1","text":"<ul> <li>http4k-connect-kakfa-rest* - Add <code>produceRecordsWithPartitions()</code> for production and partitioning in V3 API.</li> </ul>"},{"location":"changelog/#v34000","title":"v3.40.0.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> <li>http4k-connect-* - Support for multiple action types in a single module.</li> <li>http4k-connect-* - [Deprecation] Action types have been moved to super-package. Custom Actions will need to be updated.</li> <li>http4k-connect-kakfa-rest* - [Breaking] Rearrangement of action modules and start to support V3 endpoints.</li> </ul>"},{"location":"changelog/#v33920","title":"v3.39.2.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> <li>http4k-connect-amazon-dynamodb - Helper methods for creating sets and lists of value types.</li> </ul>"},{"location":"changelog/#v33910","title":"v3.39.1.0","text":"<ul> <li>http4k-connect-openai - Set a sensible limit on the number of max tokens in chat completions.</li> <li>http4k-connect-openai - [New module] Client and fake.</li> </ul>"},{"location":"changelog/#v33901","title":"v3.39.0.1","text":"<ul> <li>http4k-connect-kakfa-schemaregistry* - [Fix] Don't break on registering the same schema.</li> </ul>"},{"location":"changelog/#v33900","title":"v3.39.0.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> <li>http4k-connect-mattermost* - [New module] Initial support for a couple of actions. H/T @tkint</li> <li>http4k-connect-kakfa-schemaregistry* - [Breaking] Added some actions and tightened up types. Breaks are purely primitive -&gt; ValueType.</li> </ul>"},{"location":"changelog/#v33810","title":"v3.38.1.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> <li>http4k-connect-* - New release process.</li> </ul>"},{"location":"changelog/#v33801","title":"v3.38.0.1","text":"<ul> <li>http4k-connect-* - Add missing JsonSerializable annotation</li> </ul>"},{"location":"changelog/#v33800","title":"v3.38.0.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> </ul>"},{"location":"changelog/#v33710","title":"v3.37.1.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> <li>http4k-connect-amazon-dynamo-fake - Dynamodb query scan pagination. H/T @oharaandrew314</li> </ul>"},{"location":"changelog/#v33701","title":"v3.37.0.1","text":""},{"location":"changelog/#-_http4k-connect-amazon-dynamo_-_fixed_copy_so_that_it_does_not_stop_on_first_item","title":"- http4k-connect-amazon-dynamo* - Fixed <code>copy()</code> so that it does not stop on first item.","text":""},{"location":"changelog/#v33700","title":"v3.37.0.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies, including Kotlin to 1.8.20</li> <li>http4k-connect-amazon-dynamo* - Added <code>copy()</code> operation.</li> </ul>"},{"location":"changelog/#v33600","title":"v3.36.0.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> <li>http4k-connect-kms-fake-* - Real fake keys are now used for signing and verifying bytes.</li> </ul>"},{"location":"changelog/#v33500","title":"v3.35.0.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> </ul>"},{"location":"changelog/#v33401","title":"v3.34.0.1","text":"<ul> <li>http4k-connect-* - Fixed pagination to stop when a failure is encountered.</li> </ul>"},{"location":"changelog/#v33400","title":"v3.34.0.0","text":"<ul> <li>http4k-connect-github - Better name for GitHub webhook events  </li> </ul>"},{"location":"changelog/#v33340","title":"v3.33.4.0","text":"<ul> <li>http4k-connect-amazon-secretsmanager-* - Support for ARNs in FakeSecretsManager and in API.</li> </ul>"},{"location":"changelog/#v33330","title":"v3.33.3.0","text":"<ul> <li>http4k-connect-kakfa-schemaregistry* - Changes to register schema version API contract.</li> </ul>"},{"location":"changelog/#v33320","title":"v3.33.2.0","text":"<ul> <li>http4k-connect-kakfa-rest* - Avro records can have non-Avro keys.</li> </ul>"},{"location":"changelog/#v33310","title":"v3.33.1.0","text":"<ul> <li>http4k-connect-kakfa-schemaregistry* - Changes to register schema version API contract.</li> </ul>"},{"location":"changelog/#v33300","title":"v3.33.0.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> <li>http4k-connect-kakfa-schemaregistry* - [New module] Client and fake.</li> </ul>"},{"location":"changelog/#v33200","title":"v3.32.0.0","text":"<ul> <li>http4k-connect-kakfa-rest* - Add helpers for consuming and producing.</li> </ul>"},{"location":"changelog/#v33110","title":"v3.31.1.0","text":"<ul> <li>http4k-connect-kakfa-rest* - Adding message partitioning strategies.</li> </ul>"},{"location":"changelog/#v33100","title":"v3.31.0.0","text":"<ul> <li>http4k-connect-kakfa-rest* - [Break] Support for Avro message and Schema marshalling. Rework API for ease of use</li> </ul>"},{"location":"changelog/#v33000","title":"v3.30.0.0","text":"<ul> <li>http4k-connect-kakfa-rest* - [Rename Module] Fixes to binary message formats and auto-commit. Add Seeking for offsets.</li> </ul>"},{"location":"changelog/#v32910","title":"v3.29.1.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> <li>http4k-connect-kakfa-http-proxy* - [New module] For sending messages to Kafka without the need for the entire Kafka broker infrastructure.</li> </ul>"},{"location":"changelog/#v32900","title":"v3.29.0.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> </ul>"},{"location":"changelog/#v32800","title":"v3.28.0.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> <li>http4k-connect-sns-fake* [Breaking] Change SNSMessage to include subject and attributes</li> </ul>"},{"location":"changelog/#v32710","title":"v3.27.1.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> <li>http4k-connect-ksp-generator* - Generation of clients is now done via KSP instead of KAPT.</li> </ul>"},{"location":"changelog/#v32702","title":"v3.27.0.2","text":"<ul> <li>http4k-connect-ksp-generator* - Support for Object action classes.</li> </ul>"},{"location":"changelog/#v32701","title":"v3.27.0.1","text":"<ul> <li>http4k-connect-amazon-containercredentials - [Fix] AWS_CONTAINER_AUTHORIZATION_TOKEN is optional. </li> </ul>"},{"location":"changelog/#v32700","title":"v3.27.0.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies, including Kotlin to 1.8.0</li> <li>http4k-connect-ksp-generator* - [New module] A version of Action and Client code generator written using KSP.</li> <li>http4k-connect-amazon-instancemetadata - Add Amazon RegionProvider with environment, profile, and imds support. H/T @oharaandrew314</li> </ul>"},{"location":"changelog/#v32640","title":"v3.26.4.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies</li> <li>http4k-connect-amazon-instancemetadata - [New module]  Query metadata and credentials from the current Amazon EC2 environment. H/T @oharaandrew314</li> <li>http4k-connect-amazon-ec2credentials - Deprecated.  Use the http4k-connect-amazon-instancemetadata module</li> </ul>"},{"location":"changelog/#v32630","title":"v3.26.3.0","text":"<ul> <li>http4k-connect-cognito - We now generate action code using Kapt, as per the other clients.</li> <li>http4k-connect-cognito-fake - Fixes to login page.</li> </ul>"},{"location":"changelog/#v32620","title":"v3.26.2.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies</li> <li>http4k-connect-amazon-dynamodb - Add support for DynamoDb ImportTable and related actions. H/T @alex859</li> </ul>"},{"location":"changelog/#v32610","title":"v3.26.1.0","text":"<ul> <li>http4k-connect-amazon-dynamodb - Add tableMapper batchGet and batchDelete operations. H/T @oharaandrew314</li> <li>http4k-connect-cognito-fake - Enforce matching of Client Secret as well as ClientId </li> <li>http4k-connect-cognito-fake - Make Fake support OIDC token endpoint parameters (client_credentials_basic)</li> </ul>"},{"location":"changelog/#v32600","title":"v3.26.0.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> <li>http4k-connect-cognito* - Implement OAuth server with JWT signing and Well Known endpoint.</li> </ul>"},{"location":"changelog/#v32550","title":"v3.25.5.0","text":"<ul> <li>http4k-connect-amazon-containercredentials - Support passing of full CC URL and auth token header. This makes us compatible with AWS Snapstart</li> <li>http4k-connect-storage-http - Replace Swagger UI implementation.</li> <li>http4k-connect-* - Upgrade dependencies.</li> </ul>"},{"location":"changelog/#v32540","title":"v3.25.4.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> </ul>"},{"location":"changelog/#v32530","title":"v3.25.3.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> </ul>"},{"location":"changelog/#v32520","title":"v3.25.2.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> </ul>"},{"location":"changelog/#v32510","title":"v3.25.1.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> </ul>"},{"location":"changelog/#v32500","title":"v3.25.0.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> </ul>"},{"location":"changelog/#v32400","title":"v3.24.0.0","text":"<ul> <li>http4k-connect-google-analytics* - [New module] Split Google Analytics clients to support UA and GA4.</li> </ul>"},{"location":"changelog/#v32320","title":"v3.23.2.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies. </li> </ul>"},{"location":"changelog/#v32310","title":"v3.23.1.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies. </li> </ul>"},{"location":"changelog/#v32300","title":"v3.23.0.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies. </li> </ul>"},{"location":"changelog/#v32220","title":"v3.22.2.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> <li>http4k-connect-amazon-dynamo* - Added some useful methods for mapping Attributes such as <code>Attribute.map(BiDiMapping)</code> and <code>Attribute.list(BiDiMapping)</code></li> </ul>"},{"location":"changelog/#v32210","title":"v3.22.1.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> </ul>"},{"location":"changelog/#v32200","title":"v3.22.0.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies, including Kotlin to 1.7.20.</li> </ul>"},{"location":"changelog/#v32131","title":"v3.21.3.1","text":"<ul> <li>http4k-connect-* - Republish of 3.21.3.0.</li> </ul>"},{"location":"changelog/#v32130","title":"v3.21.3.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> <li>http4k-connect-core - Tweak to ProfileCredentialsProvider. H/T @oharaandrew314</li> </ul>"},{"location":"changelog/#v32121","title":"v3.21.2.1","text":"<ul> <li>http4k-connect-* - Republish of 3.21.2.0.</li> </ul>"},{"location":"changelog/#v32120","title":"v3.21.2.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> </ul>"},{"location":"changelog/#v32110","title":"v3.21.1.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> </ul>"},{"location":"changelog/#v32100","title":"v3.21.0.0","text":"<ul> <li>http4k-connect-amazon-sns-fake* - [Unlikely Break] FakeSNS now works on a single region only - so published messages need to match the region which the Fake was created with.</li> </ul>"},{"location":"changelog/#v32000","title":"v3.20.0.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> <li>http4k-connect-amazon-sns-fake* - [Breaking] Enable setting of region - this now defaults to the test region <code>ldn-north-1</code>, but you can override if you need to do so in your testing environment.</li> </ul>"},{"location":"changelog/#v31920","title":"v3.19.2.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> </ul>"},{"location":"changelog/#v31910","title":"v3.19.1.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> </ul>"},{"location":"changelog/#v31900","title":"v3.19.0.0","text":"<ul> <li>http4k-connect-amazon-ses - Allow both text and html body on emails.</li> </ul>"},{"location":"changelog/#v31813","title":"v3.18.1.3","text":"<ul> <li>http4k-connect-amazon-dynamodb-fake - Fix batchWriteItem with multiple requests per table. H/T @oharaandrew314</li> </ul>"},{"location":"changelog/#v31812","title":"v3.18.1.2","text":"<ul> <li>http4k-connect-amazon-dynamodb-fake - Fix request/response for fake dynamodb batch operations. H/T @oharaandrew314</li> </ul>"},{"location":"changelog/#v31811","title":"v3.18.1.1","text":"<ul> <li>http4k-connect-amazon-dynamodb-fake - <code>PutItem</code> now only replaces items with the correct Primary Key. H/T @oharaandrew314</li> </ul>"},{"location":"changelog/#v31810","title":"v3.18.1.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> <li>http4k-connect-* - Added convenience automarshalling for pagination.</li> <li>http4k-connect-amazon-dynamodb-fake - New actions supported: <code>Query</code>, <code>Scan</code>, <code>Updateitem</code>. H/T @oharaandrew314 for the contributions.</li> </ul>"},{"location":"changelog/#v31800","title":"v3.18.0.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies, including Kotlin to 1.7.0.</li> </ul>"},{"location":"changelog/#v31731","title":"v3.17.3.1","text":"<ul> <li>http4k-connect-* - Fix broken POMs which removed all runtime dependencies</li> </ul>"},{"location":"changelog/#v31730","title":"v3.17.3.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> </ul>"},{"location":"changelog/#v31720","title":"v3.17.2.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies, including Kotlin to 1.6.21.</li> <li>http4k-connect-amazon-dynamodb- - Add auto Lens extensions for object mapping: <code>Moshi.autoDynamoLens&lt;AnObject&gt;()</code></li> </ul>"},{"location":"changelog/#v31710","title":"v3.17.1.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies, including Kotlin to 1.6.20.</li> </ul>"},{"location":"changelog/#v31700","title":"v3.17.0.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> <li>http4k-connect-amazon-containercredentials Added loading of credentials from Container Credentials service.</li> <li>http4k-connect-amazon-containercredentials-fake - [New module] Fake for the above.</li> <li>http4k-connect-amazon-sts-* - [Unlikely break] Repackaged Credentials to core.</li> </ul>"},{"location":"changelog/#v31660","title":"v3.16.6.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> </ul>"},{"location":"changelog/#v31650","title":"v3.16.5.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> </ul>"},{"location":"changelog/#v31640","title":"v3.16.4.0","text":"<ul> <li>http4k-connect-amazon-kms* - EncryptionAlgorithms in GetPublicKey is optional (but not according to the AWS docs... )</li> </ul>"},{"location":"changelog/#v31630","title":"v3.16.3.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> <li>http4k-connect-amazon-sts - WebIdentityToken provider refreshes token from disc on re-auth.</li> </ul>"},{"location":"changelog/#v31620","title":"v3.16.2.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> </ul>"},{"location":"changelog/#v31610","title":"v3.16.1.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> <li>http4k-connect-amazon-* - Add missing exception message in the case of remote failure.</li> </ul>"},{"location":"changelog/#v31600","title":"v3.16.0.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> <li>http4k-connect-storage-jdbc* - [Possible break] Due to upgrade of Exposed and H2SQL - API differences. Need to fix as required.</li> <li>http4k-connect-amazon.dynamodb - Support defaulted() for falling back to another column.</li> </ul>"},{"location":"changelog/#v31521","title":"v3.15.2.1","text":"<ul> <li>http4k-connect-amazon-* - AssumeRoleWithWebIdentity response has optional fields which are not documented. Grrrr.</li> </ul>"},{"location":"changelog/#v31520","title":"v3.15.2.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> <li>http4k-connect-amazon-* - Fix #105 - WebIdentityProvider to STS does not set host name when refreshing token. </li> </ul>"},{"location":"changelog/#v31510","title":"v3.15.1.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> <li>http4k-connect-amazon.dynamodb - [Fix] ConsumedCapacity is not a long</li> </ul>"},{"location":"changelog/#v31500","title":"v3.15.0.0","text":"<ul> <li>http4k-connect-* - [Breaking] Upgrade dependencies. The http4k upgrade must be done in lockstep with this version as there has been a breaking change in http4k.</li> </ul>"},{"location":"changelog/#v31400","title":"v3.14.0.0","text":"<ul> <li>http4k-connect-* - [Break] Upgrade of Forkhandles to v2.0.0.0 means some unfortunately exposed constructor methods have gone away. Simple to fix - deprecation warnings will take care of it.</li> <li>http4k-connect-* - Upgrade dependencies and Kotlin to 1.6.10.</li> </ul>"},{"location":"changelog/#v31310","title":"v3.13.1.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> <li>http4k-storage-redis-* - Vary lifetime of items.</li> </ul>"},{"location":"changelog/#v31300","title":"v3.13.0.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies and Kotlin to 1.6.0.</li> <li>http4k-connect-* - [Break] Changes to Kotshi mean that JsonFactories are now interfaces instead of abstract classes.</li> </ul>"},{"location":"changelog/#v31220","title":"v3.12.2.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies and Gradle.</li> </ul>"},{"location":"changelog/#v31211","title":"v3.12.1.1","text":"<ul> <li>http4k-connect-* - Fix Base64 decoding of ByteArrays(roundtripping).</li> </ul>"},{"location":"changelog/#v31210","title":"v3.12.1.0","text":"<ul> <li>http4k-connect-amazon-dynamodb* - Add defaulted() to Attribute Lenses</li> </ul>"},{"location":"changelog/#v31200","title":"v3.12.0.0","text":"<ul> <li>http4k-connect-amazon-dynamodb* - [Breaking] Fix TransactionGetItems to not blow up if item missing. Item is now nullable in response.</li> </ul>"},{"location":"changelog/#v31120","title":"v3.11.2.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies</li> </ul>"},{"location":"changelog/#v31110","title":"v3.11.1.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies</li> <li>http4k-amazon-ses* - [New module] client and Fake for SES. @H/T ToastShaman</li> </ul>"},{"location":"changelog/#v31101","title":"v3.11.0.1","text":"<ul> <li>http4k-connect-* - Upgrade dependencies</li> <li>http4k-connect-github - [Break] Replace Secret with GitHubToken in rest of API.</li> </ul>"},{"location":"changelog/#v31001","title":"v3.10.0.1","text":"<ul> <li>http4k-connect-amazon-sqs-fake - [Fix] Calculated attribute MD5 was incorrect. </li> </ul>"},{"location":"changelog/#v31000","title":"v3.10.0.0","text":"<ul> <li>http4k-connect-amazon-sqs - [Breaking] Parsing of message attributes in ReceiveMessage is implemented. SQS docs are wrong... </li> </ul>"},{"location":"changelog/#v3900","title":"v3.9.0.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies</li> <li>http4k-connect-github - [Break] Replace Secret with GitHubToken in filters.</li> </ul>"},{"location":"changelog/#v3830","title":"v3.8.3.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies</li> <li>http4k-connect-amazon-sqs-* - Support ListQueues.</li> </ul>"},{"location":"changelog/#v3820","title":"v3.8.2.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies</li> <li>http4k-connect-github - Fixing up to make 404s possible in the GitHub action.</li> </ul>"},{"location":"changelog/#v3811","title":"v3.8.1.1","text":"<ul> <li>http4k-connect-amazon-sqs-fake - Make MD5 of SQS messages pad right to 32 chars.</li> </ul>"},{"location":"changelog/#v3810","title":"v3.8.1.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies, including Kotlin to 1.5.30.</li> <li>http4k-connect-amazon-sts* - Added convenience functions for Credential Providers.</li> </ul>"},{"location":"changelog/#v3800","title":"v3.8.0.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> <li>http4k-connect-amazon-sts* - Support STS (refreshing) Credential providers including by WebIdentityToken.</li> </ul>"},{"location":"changelog/#v3700","title":"v3.7.0.0","text":"<ul> <li>http4k-connect-amazon-sqs* - [Breaking] Change to use QueueUrl universally. This ia much more consistent and aligns with the behaviour of the standard AWS SDK. You will need to update your configurations to pass in the urls instead of the standard queue names/ARNs</li> </ul>"},{"location":"changelog/#v3640","title":"v3.6.4.0","text":"<ul> <li>http4k-connect-amazon-sqs* - Support GetQueueAttributes</li> </ul>"},{"location":"changelog/#v3632","title":"v3.6.3.2","text":"<ul> <li>http4k-connect-* - Upgrade dependencies.</li> <li>http4k-connect-amazon-sqs* - Fix ReceiveMessage to correctly return requested number of messages.</li> </ul>"},{"location":"changelog/#v3631","title":"v3.6.3.1","text":"<ul> <li>http4k-connect-amazon-sqs* - Fix ReceiveMessage to correctly handle multiple messages.</li> </ul>"},{"location":"changelog/#v3630","title":"v3.6.3.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies, including http4k to 4.11.0.1.</li> <li>http4k-connect-amazon-sqs* - Support for WaitTimeSeconds when receiving messages.</li> </ul>"},{"location":"changelog/#v3620","title":"v3.6.2.0","text":"<ul> <li>http4k-connect-amazon-s3* - Add <code>HeadBucket</code> and <code>HeadKey</code></li> <li>http4k-connect-* - Upgrade dependencies, including http4k to 4.10.1.0.</li> </ul>"},{"location":"changelog/#v3610","title":"v3.6.1.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies, including http4k to 4.10.0.1.</li> </ul>"},{"location":"changelog/#v3600","title":"v3.6.0.0","text":"<ul> <li>http4k-connect-amazon-s3-fake* - Fix FakeS3 CopyKey command. H/T @ToastShaman</li> <li>http4k-connect-* - Upgrade dependencies, including http4k to 4.9.10.0.</li> </ul>"},{"location":"changelog/#v3510","title":"v3.5.1.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies, including http4k to 4.9.9.0.</li> <li>http4k-connect-github : Fix token usage and add <code>authScheme</code> parameter.</li> </ul>"},{"location":"changelog/#v3500","title":"v3.5.0.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies, including http4k to 4.9.8.0.</li> <li>http4k-connect-*-fake [Breaking] Replaced usage of <code>ChaosFake</code> with the <code>ChaoticHttpHandler</code> from http4k. Nothing massive, but you may need to update some imports as they have moved</li> </ul>"},{"location":"changelog/#v3420","title":"v3.4.2.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies, including http4k to 4.9.7.0.</li> <li>http4k-connect-amazon-s3-fake - Fix #56 - S3(Fake): preserve encoding in bucketGetKey - H/T @tkint </li> </ul>"},{"location":"changelog/#v3410","title":"v3.4.1.0","text":"<ul> <li>http4k-connect-google-analytics - [New module] Added support for GA events.</li> </ul>"},{"location":"changelog/#v3400","title":"v3.4.0.0","text":"<ul> <li>http4k-connect-amazon-* - Region is now not reliant on default AWS format. This helps with on-prem installations with non-standard region format.</li> <li>http4k-connect-google-analytics - [Breaking] Moved Tracking ID out of pageView and into client as is global.</li> </ul>"},{"location":"changelog/#v3330","title":"v3.3.3.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies, including http4k to 4.9.5.0.</li> </ul>"},{"location":"changelog/#v3320","title":"v3.3.2.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies, including http4k to 4.9.3.1.</li> </ul>"},{"location":"changelog/#v3310","title":"v3.3.1.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies, including http4k to 4.9.1.0.</li> </ul>"},{"location":"changelog/#v3300","title":"v3.3.0.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies, including http4k to 4.9.0.2.</li> <li>http4k-connect-amazon-lambda : Introduction of <code>invokeStreamFunction()</code> action to allow for calling functions without.</li> </ul>"},{"location":"changelog/#v3201","title":"v3.2.0.1","text":"<ul> <li>http4k-connect-amazon-s3 : Fix S3 not returning LastModified value correctly in <code>ListObjectsV2</code></li> </ul>"},{"location":"changelog/#v3200","title":"v3.2.0.0","text":"<ul> <li>http4k-connect-* - Upgrade dependencies</li> <li>http4k-connect-amazon-dynamodb : [Slight break] <code>BatchGetItem</code> and <code>BatchWriteItem</code> actions had incorrect key names for response classes.</li> </ul>"},{"location":"changelog/#v3110","title":"v3.1.1.0","text":"<ul> <li>http4k-connect-amazon-cognito - [New module] Base actions for user client and pool creation are implemented, no fake as yet.</li> </ul>"},{"location":"changelog/#v3101","title":"v3.1.0.1","text":"<ul> <li>http4k-connect-amazon-dynamodb : Removed non-nullable field on ConsumedCapacity.</li> </ul>"},{"location":"changelog/#v3100","title":"v3.1.0.0","text":"<ul> <li>http4k-connect-amazon-s3* : Add support for path-based bucket operations (ie. buckets with <code>.</code> in the name)</li> <li>http4k-connect-amazon-s3* : [Rename break] Renamed <code>*Key</code> actions to match S3 API (now <code>*Object</code>)</li> <li>http4k-connect-amazon-s3* : [Slight break] Add headers to <code>PutObject</code>.</li> </ul>"},{"location":"changelog/#v3030","title":"v3.0.3.0","text":"<ul> <li>http4k-connect-* : Add convenience functions for getting AWS environmental variables from an http4k Environment object.</li> </ul>"},{"location":"changelog/#v3020","title":"v3.0.2.0","text":"<ul> <li>http4k-connect-* : Upgrade http4k.</li> </ul>"},{"location":"changelog/#v3010","title":"v3.0.1.0","text":"<ul> <li>http4k-connect-* : Add Moshi serializers for enums, making them compatible with GraalVM</li> </ul>"},{"location":"changelog/#v3000","title":"v3.0.0.0","text":"<ul> <li>http4k-connect-* : Major repackage of all model classes. Model package has been normalised to <code>org.http4k.connect.amazon.&lt;system&gt;.model</code>. All non-top level message objects have been moved from the <code>org.http4k.connect.amazon.&lt;system&gt;.action</code> package into <code>org.http4k.connect.amazon.&lt;system&gt;.model</code>. This is probably very annoying, and apologies in advance - hence the major version uptick. We are not proud of ourselves, but it needed to be done for our future plans... Also imports of generated client methods may need to be altered as some of them were in teh wrong place.</li> </ul>"},{"location":"changelog/#v22300","title":"v2.23.0.0","text":"<ul> <li>http4k-connect-amazon-dynamodb : [Slight break] Repackaging work of item types to reuse them for Dynamo event marshalling.</li> </ul>"},{"location":"changelog/#v22210","title":"v2.22.1.0","text":"<ul> <li>http4k-connect-amazon-dynamodb : Support Dynamo Events in marshalling layer.</li> </ul>"},{"location":"changelog/#v22201","title":"v2.22.0.1","text":"<ul> <li>http4k-connect-amazon-dynamodb : Fix incorrectly specified data type for OffsetDateTime attributes.</li> </ul>"},{"location":"changelog/#v22200","title":"v2.22.0.0","text":"<ul> <li>http4k-connect-amazon-dynamodb : [Breaking] Change <code>value()</code> method on <code>Attribute</code> to be typed. This only affects you if you are using <code>values4k</code> value classes for column mappings.</li> </ul>"},{"location":"changelog/#v22111","title":"v2.21.1.1","text":"<ul> <li>http4k-connect-amazon-dynamodb : Fix long value stored as a string.</li> </ul>"},{"location":"changelog/#v22110","title":"v2.21.1.0","text":"<ul> <li>http4k-connect-* : Add default values to all nullable response message fields. This is better for when stubbing/mocking out the responses.</li> </ul>"},{"location":"changelog/#v22100","title":"v2.21.0.0","text":"<ul> <li>http4k-connect-* : [Breaking] Repackaged Pagination classes (not just Amazon anymore).</li> <li>http4k-connect-* : [Breaking] Added pagination of results to relevant actions using <code>xyzPaginated()</code> actions. Removed usage of <code>Listing</code> classes. This is a more convenient API to use and is consistent throughout all modules.</li> </ul>"},{"location":"changelog/#v22111_1","title":"v2.21.1.1","text":"<ul> <li>http4k-connect-amazon-dynamodb : Fix bug with Long data type. @H/T @ToastShaman for the tip off.</li> </ul>"},{"location":"changelog/#v22010","title":"v2.20.1.0","text":"<ul> <li>http4k-connect-amazon-dynamodb : Added pagination of results</li> </ul>"},{"location":"changelog/#v22000","title":"v2.20.0.0","text":"<ul> <li>http4k-connect-amazon-dynamodb : More making API nicer and typesafe.</li> </ul>"},{"location":"changelog/#v21900","title":"v2.19.0.0","text":"<ul> <li>http4k-connect-amazon-* : [Breaking] Changed generated helper functions to not interfere with the names of the parameters. Simple rename will work here.</li> <li>http4k-connect-* : Friendlify JavaDocs.</li> </ul>"},{"location":"changelog/#v21810","title":"v2.18.1.0","text":"<ul> <li>http4k-connect-amazon-cloudfront : [New module]</li> <li>*http4k-connect-amazon-cloudfront-fake : [New module]</li> </ul>"},{"location":"changelog/#v21800","title":"v2.18.0.0","text":"<ul> <li>http4k-connect-amazon-dynamodb : Further tweaking of the Item and Key mapping typealiases to make API easier to use.</li> </ul>"},{"location":"changelog/#v21700","title":"v2.17.0.0","text":"<ul> <li>http4k-connect-amazon-dynamodb : Reworked DynamoDb API to be typesafe, tightened up types in responses, added Scan.</li> </ul>"},{"location":"changelog/#v21600","title":"v2.16.0.0","text":"<ul> <li>http4k-connect-amazon-dynamodb : [New module] New client module. No fake as yet.</li> <li>http4k-connect-amazon-* : [Break] Rename <code>Base64Blob.encoded()</code> -&gt; <code>Base64Blob.encode()</code> for clarity.</li> </ul>"},{"location":"changelog/#v21540","title":"v2.15.4.0","text":"<ul> <li>http4k-connect-github : Add infra for main GitHub client. No custom actions implemented yet.</li> </ul>"},{"location":"changelog/#v21530","title":"v2.15.3.0","text":"<ul> <li>http4k-connect-github : [New module] Containing only basic callback infrastructure and Filters for checking requests.</li> </ul>"},{"location":"changelog/#v21520","title":"v2.15.2.0","text":"<ul> <li>http4k-connect-* : upgrade http4k. This should Fix #17 (Enable custom domain in S3).</li> </ul>"},{"location":"changelog/#v21510","title":"v2.15.1.0","text":"<ul> <li>http4k-connect-* : upgrade http4k, Kotlin.</li> </ul>"},{"location":"changelog/#v21501","title":"v2.15.0.1","text":"<ul> <li>Switch to Maven Central publishing as first options</li> </ul>"},{"location":"changelog/#v21500","title":"v2.15.0.0","text":"<ul> <li>http4k-connect-google-analytics : [Break] Harmonised interface with other clients. TrackingId now moved  to individual requests</li> </ul>"},{"location":"changelog/#v21420","title":"v2.14.2.0","text":"<ul> <li>http4k-connect-* : upgrade http4k, kotlin, others</li> </ul>"},{"location":"changelog/#v21410","title":"v2.14.1.0","text":"<ul> <li>http4k-connect-* : upgrade http4k</li> <li>http4k-connect-kapt-generator : Un-hardcode result type as per Action interface. </li> </ul>"},{"location":"changelog/#v21400","title":"v2.14.0.0","text":"<ul> <li>http4k-connect-* : [Breaking] Changed Result type on Action to be generic to support other programming models. This will only affect users who are implementing their own clients. To fix, change: </li> </ul> <pre><code>interface MyClient&lt;R&gt; : Action&lt;R&gt;\n// to \ninterface MyClient&lt;R&gt; : Action&lt;Result&lt;R, RemoteFailure&gt;&gt;\n</code></pre>"},{"location":"changelog/#v21301","title":"v2.13.0.1","text":"<ul> <li>*http4k-connect-amazon-s3-fake : Send response XML as well as status code on errors.</li> </ul>"},{"location":"changelog/#v21300","title":"v2.13.0.0","text":"<ul> <li>http4k-connect-* : Rejig of dependencies to be consistent.</li> </ul>"},{"location":"changelog/#v21200","title":"v2.12.0.0","text":"<ul> <li>http4k-connect-storage-core : New module, containing storage abstractions which can be used without the fakes.</li> </ul>"},{"location":"changelog/#v21100","title":"v2.11.0.0","text":"<ul> <li>http4k-connect-amazon-sns : [New module]</li> <li>*http4k-connect-amazon-sns-fake : [New module]</li> <li>http4k-connect- : Make all action classes Data classes so they are test friendly</li> <li>http4k-connect-amazon-sqs : [Breaking] Tags is now a <code>List&lt;Tag&gt;</code> instead of a <code>Map&lt;String, String&gt;</code>.</li> </ul>"},{"location":"changelog/#v21000","title":"v2.10.0.0","text":"<ul> <li>http4k-connect-amazon- : Add convenience functions to create clients from the system environment. </li> <li>http4k-connect-amazon- : Removed unused Payload type for various clients.</li> <li>http4k-connect-* : Upgrade values4k and http4k</li> </ul>"},{"location":"changelog/#v2920","title":"v2.9.2.0","text":"<ul> <li>http4k-connect-amazon- : Add convenience methods for constructing AWS clients</li> </ul>"},{"location":"changelog/#v2910","title":"v2.9.1.0","text":"<ul> <li>http4k-connect-amazon- : Expose Moshi to client API users for JSON-based systems</li> </ul>"},{"location":"changelog/#v2900","title":"v2.9.0.0","text":"<ul> <li>http4k-connect-amazon-sqs : Fixed SQS MessageAttributes as API is not as advertised...</li> <li>http4k-connect-amazon-fake : Extracting out endpoints for easier extension.</li> </ul>"},{"location":"changelog/#v2800","title":"v2.8.0.0","text":"<ul> <li>http4k-connect-* : Upgrade to http4k 4.X.X.X.</li> </ul>"},{"location":"changelog/#v2710","title":"v2.7.1.0","text":"<ul> <li>http4k-connect-amazon-systemsmanager : Refined model.</li> <li>http4k-connect-amazon-* : Fixed handling of ARNs.</li> </ul>"},{"location":"changelog/#v2700","title":"v2.7.0.0","text":"<ul> <li>http4k-connect-amazon-* : Refined ARN model.</li> <li>http4k-connect-amazon-s3 : Fix Delete Bucket action.</li> </ul>"},{"location":"changelog/#v2600","title":"v2.6.0.0","text":"<ul> <li>http4k-connect-amazon-* : API improvements for all AWS services.</li> <li>http4k-connect-* : <code>defaultPort()</code> -&gt; <code>defaultPort</code></li> </ul>"},{"location":"changelog/#v2510","title":"v2.5.1.0","text":"<ul> <li>*http4k-connect-amazon-lambda : Expose AutoMarshalling in extension function.</li> </ul>"},{"location":"changelog/#v2500","title":"v2.5.0.0","text":"<ul> <li>*http4k-connect-amazon-lambda : Expose <code>AutoMarshalling</code> for invoking functions.</li> </ul>"},{"location":"changelog/#v2400","title":"v2.4.0.0","text":"<ul> <li>http4k-connect- : Remove need for AWSCredentialScope - just use Region instead since each service already knows the scope required.</li> </ul>"},{"location":"changelog/#v2320","title":"v2.3.2.0","text":"<ul> <li>*http4k-connect-amazon-sqs : [New module] Client and fake.</li> <li>*http4k-connect-amazon-sqs-fake : [New module] See README for limitations of FakeSQS.</li> <li>*http4k-connect-amazon-sts : Added STSCredentialsProvider to refresh credentials when required.</li> </ul>"},{"location":"changelog/#v2311","title":"v2.3.1.1","text":"<ul> <li>http4k-connect- : Fix #11 thread safety of DocumentBuilderFactory.</li> </ul>"},{"location":"changelog/#v2310","title":"v2.3.1.0","text":"<ul> <li>*http4k-connect-amazon-lambda : [New module] Support for invoking AWS Lambda functions.</li> <li>*http4k-connect-amazon-lambda-fake : [New module] Includes FakeLambda runtime to run/deploy named HttpHandlers into.</li> </ul>"},{"location":"changelog/#v2300","title":"v2.3.0.0","text":"<ul> <li>http4k-connect- : Use Kotshi generated adapters instead of Kotlin Reflection, allowing removal of large Kotlin Reflection JAR. Note that the Kotlin-reflect dependency must be explicitly excluded due to transitivity in your projects.</li> </ul>"},{"location":"changelog/#v2220","title":"v2.2.2.0","text":"<ul> <li>http4k-connect- : Generate and ship extension functions for all actions. Rename <code>S3.Bucket</code> to <code>S3Bucket</code>.</li> </ul>"},{"location":"changelog/#v2210","title":"v2.2.1.0","text":"<ul> <li>http4k-connect- : Ship Javadoc.</li> </ul>"},{"location":"changelog/#v2200","title":"v2.2.0.0","text":"<ul> <li>http4k-connect- : Repackage all action classes.</li> </ul>"},{"location":"changelog/#v2100","title":"v2.1.0.0","text":"<ul> <li>http4k-connect- : Repackage all action classes.</li> </ul>"},{"location":"changelog/#v2021","title":"v2.0.2.1","text":"<ul> <li>http4k-connect- : Switch all interfaces to use new <code>invoke()</code> mechanism.</li> </ul>"},{"location":"changelog/#v1101","title":"v1.1.0.1","text":"<ul> <li>http4k-connect- : Upgrade http4k and Values4k.</li> </ul>"},{"location":"changelog/#v1010","title":"v1.0.1.0","text":"<ul> <li>http4k-connect-amazon-kms-fake : Simplify signing.</li> </ul>"},{"location":"changelog/#v1000","title":"v1.0.0.0","text":"<ul> <li>http4k-connect-amazon-kms : [New module] New client module.</li> <li>http4k-connect-amazon-kms-fake : [New module] New client fake module.</li> <li>http4k-connect-amazon-s3 : [New module] New client module.</li> <li>http4k-connect-amazon-s3-fake : [New module] New client fake module.</li> <li>http4k-connect-amazon-secretsmanager : [New module] New client module.</li> <li>http4k-connect-amazon-secretsmanager-fake : [New module] New client fake module.</li> <li>http4k-connect-amazon-systemsmanager : [New module] New client module.</li> <li>http4k-connect-amazon-systemsmanager-fake : [New module] New client fake module.</li> <li>http4k-connect-google-analytics : [New module] New client module.</li> <li>http4k-connect-storage-http : [New module] New storage module.</li> <li>http4k-connect-storage-jdbc : [New module] New storage module.</li> <li>http4k-connect-storage-redis : [New module] New storage module.</li> <li>http4k-connect-storage-s3 : [New module] New storage module.</li> </ul>"},{"location":"changelog/#v02000","title":"v0.20.0.0","text":"<ul> <li>Initial release.</li> </ul>"},{"location":"code-of-conduct/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"code-of-conduct/#our_pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"code-of-conduct/#our_standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the   overall community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or   advances of any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email   address, without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"code-of-conduct/#enforcement_responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"code-of-conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"code-of-conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at contact@http4k.org. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"code-of-conduct/#enforcement_guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"code-of-conduct/#1_correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"code-of-conduct/#2_warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"code-of-conduct/#3_temporary_ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"code-of-conduct/#4_permanent_ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior,  harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"code-of-conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"contributing/","title":"http4k-connect contributions","text":""},{"location":"contributing/#notes_for_adding_a_new_client_fake","title":"Notes for adding a new Client &amp; Fake","text":"<ul> <li>Use the <code>Example</code> project client and fake as a template module.</li> <li>The naming of the modules is: <code>http4k-connect-&lt;vendor&gt;-&lt;system&gt;</code>. We are also grouping the systems by vendor in directory structure. To add the modules in the right place in <code>settings.gradle.kts</code> use the functions provided.</li> <li>The work for adding other <code>http4k-connect</code> Gradle dependencies is already done in the core <code>build.gradle</code> file. You just need to add external dependencies into the module gradle file if there are any. If not, feel free to omit it.</li> <li>Fakes should extend <code>ChaoticHttpHandler</code>, which adds in the <code>misbehave()</code> and <code>behave()</code> functions to enable the Chaotic behaviour.</li> <li>Each Fake should implement the <code>FakeSystemContract</code>.</li> <li>Tests against external systems should be added wherever possible to prove the contracts are in place, or adding Docker setup to run them.  This is work in progress.</li> </ul>"},{"location":"contributing/#notes_for_adding_storage_implementations","title":"Notes for adding Storage implementations","text":"<ul> <li>The naming of the modules is: <code>http4k-connect-storage-&lt;type&gt;</code>. To add the module in the right place in <code>settings.gradle.kts</code> use the function provided.</li> <li>There is a contract <code>StorageContract</code> to prove that the implementation.</li> <li>Testcontainers can be used to prove out testing for various storage backends</li> </ul>"},{"location":"documentation/","title":"Introduction","text":"<p>http4k Connect is a lightweight API Client toolkit which includes libraries for connecting to popular third-party cloud  services and AI backends using http4k compatible APIs, along with Fake implementations for usage during local testing. These are all underpinned by a variation on the uniform Server as a Function model powered by the <code>HttpHandler</code> interface exposed by http4k, so you can:</p> <ol> <li>Take advantage of the simple and powerful SaaF model and APIs used in http4k.</li> <li>Plug everything together completely in-memory and take advantage of this powerful model.</li> <li>Have access to the underlying HTTP clients (and hence add metrics or logging).</li> <li>Run stateful Fake implementations of 3rd party systems locally or in test environments.</li> </ol> <p>Although centered around usage in http4k-based projects, http4k-connect does not require this and the libraries are usable from any JVM application.</p>"},{"location":"documentation/#rationale","title":"Rationale","text":"<p>Although convenient, many API Client libraries introduce many heavyweight dependencies or contain a plethora of non-required functionality, which can have a large effect on binary size. As an alternative, http4k-connect provides lightweight versions of popular APIs covering standard use-cases.</p>"},{"location":"documentation/#installation","title":"Installation","text":"<pre><code>dependencies {\n    // install the platform...\n    implementation(platform(\"org.http4k:http4k-connect-bom:5.24.1.0\"))\n\n    // ...then choose an API Client\n    implementation(\"org.http4k:http4k-connect-amazon-s3\")\n\n    // ...a fake for testing\n    testImplementation(\"org.http4k:http4k-connect-amazon-s3-fake\")\n\n    // ...and a storage backend (optional)\n    testImplementation(\"org.http4k:http4k-connect-storage-redis\")\n}\n</code></pre>  The main documentation has moved to the http4k Connect [site](https://connect.http4k.org)"},{"location":"documentation/#supported_apis_and_fakes","title":"Supported APIs and Fakes:","text":"<p>See the Module Reference for the complete list of supported services.</p>  - [Example Template](./example) -&gt; `\"org.http4k:http4k-connect-example\"` / `\"org.http4k:http4k-connect-example-fake\"`"},{"location":"documentation/#want_to_add_a_new_api_client_or_storage_backend","title":"Want to add a new API Client or Storage backend?","text":"<p>Read the guide.</p>"},{"location":"guide/concepts/api-clients/","title":"API Clients","text":"<p>Each system API Client is modelled as a single function with arity 1 (that is it takes only a single parameter) returning a Result4k Success/Failure monad type), which is known as an <code>Action</code>. The Client is responsible for managing the overall protocol with the remote system. There are also a set of extension methods generated to provide a more traditional function-based version of the same interface.</p> <p>The module naming scheme for API Clients is:</p>"},{"location":"guide/concepts/api-clients/#orghttp4khttp4k-connect-vendor-system","title":"org.http4k:http4k-connect-{vendor}-{system}","text":"<p>Action classes are responsible for constructing the HTTP requests and unmarshalling their responses into the http4k-connect types. There are lots of common actions built-in, but you can provide your own by simply implementing the relevant Action interface. The recommended pattern in http4k-connect is to use a Result monad type (we use Result4k) to represent the result type, but you can use anything to suit your programming model.</p> <pre><code>// Generic system interface\ninterface Example {\n   operator fun &lt;R : Any&gt; invoke(request: ExampleAction&lt;R&gt;): Result&lt;R, RemoteFailure&gt;\n}\n\n// System-specific action\ninterface ExampleAction&lt;R&gt; : Action&lt;Result&lt;R, RemoteFailure&gt;&gt;\n\n// Action and response classes\ndata class Echo(val value: String) : ExampleAction&lt;Echoed&gt;\ndata class Echoed(val value: String)\n\n// Traditional function helpers\nfun Example.echo(value: String): Result&lt;Echoed, RemoteFailure&gt; = this(Echo(value))\n</code></pre>"},{"location":"guide/concepts/api-clients/#example_usage","title":"Example usage","text":"<pre><code>// constructing and using the clients\nval example = Example.Http(httpHandler)\n\nval echoed: Result&lt;Echoed, RemoteFailure&gt; = example.echo(\"hello world\")\n// or...\nval alsoEchoed: Result&lt;Echoed, RemoteFailure&gt; = example(Echo(\"hello world\"))\n</code></pre>"},{"location":"guide/concepts/system-fakes/","title":"System Fakes","text":"<p>Each module comes with it's own Fake system which implements the remote HTTP interface. In like with the <code>Server as a Function</code> concept, this Fake class implements <code>HttpHandler</code> and:</p> <ol> <li>Can be used in in-memory tests as a swap-out replacement for an HTTP client</li> <li>Can be started and bound to a HTTP port - each Fake has it's own unique port</li> <li>Can be deployed into test environments as a replacement for the real thing.</li> <li>Can be used to simulate Chaotic behaviour using the built in OpenApi interface (see http://localhost:/chaos) <p>The module naming scheme for Fakes is:</p>"},{"location":"guide/concepts/system-fakes/#orghttp4khttp4k-connect-vendor-system-fake","title":"org.http4k:http4k-connect-{vendor}-{system}-fake","text":"<p>Inject the fake in place of a standard HTTP Handler, or start the Fake as a server with:</p> <pre><code>FakeExample().start()\n&gt; Started FakeExample on 22375\n</code></pre>"},{"location":"guide/howto/implement-your-own-clients/","title":"Implement your own API clients","text":"<p>It is very easy to implement your own clients to follow the pattern. For the system <code>MySystem</code>, you would need to:</p> <ol> <li>Depend on the <code>http4k-connect-core</code> artifact</li> <li>Add an Action interface and implementation:</li> </ol> <pre><code>interface MySystemAction&lt;R&gt; : Action&lt;R&gt;\n\ndata class Echo(val value: String) : MySystemAction&lt;Echoed&gt; {\n    override fun toRequest() = Request(GET, \"echo\").body(value)\n    override fun toResult(response: Response) = Echoed(response.bodyString())\n}\n\ndata class Echoed(val value: String)\n</code></pre> <ol> <li>Add your client interface and HTTP implementation:</li> </ol> <pre><code>interface MySystem {\n    operator fun &lt;R : Any&gt; invoke(action: MySystemAction&lt;R&gt;): R\n\n    companion object\n}\n\nfun MySystem.Companion.Http(http: HttpHandler) = object : MySystem {\n    override fun &lt;R : Any&gt; invoke(action: MySystemAction&lt;R&gt;) = action.toResult(http(action.toRequest()))\n}\n</code></pre> <p>See also the guide on using KSP to generate extension functions for your clients!</p>"},{"location":"guide/howto/pimp-your-clients-with-ksp/","title":"Pimp your API Clients with KSP!","text":"<p>http4k-connect ships with a KSP plugin to automate the generation of the client extension-methods that accompany each Connect client. This allows you to skip creating those extensions manually and maintain the API of the client appears to contain methods for each Action.</p>"},{"location":"guide/howto/pimp-your-clients-with-ksp/#generating_extension_methods_for_your_clients","title":"Generating extension methods for your clients","text":"<p>1 - Define your base Action (and interface) using the http4k base class and tag it with the Http4kConnectAction annotation:</p> <pre><code>interface APIAction&lt;R&gt; : Action&lt;Result&lt;R, RemoteFailure&gt;&gt;\n\n@Http4kConnectAction\ndata class Reverse(val value: String) : APIAction&lt;String&gt; {\n    override fun toRequest() = Request(POST, \"/reverse\").body(value)\n\n    override fun toResult(response: Response): Result&lt;String, RemoteFailure&gt; =\n        Success(response.bodyString())\n}\n</code></pre> <p>2 - Define your API Client, tagging it with the Http4kConnectClient annotation:</p> <pre><code>@Http4kConnectClient\nclass API(rawHttp: HttpHandler) {\n    private val transport = SetBaseUriFrom(Uri.of(\"https://api.com\"))\n        .then(rawHttp)\n\n    operator fun &lt;R&gt; invoke(action: APIAction&lt;R&gt;): Result&lt;R, RemoteFailure&gt; =\n        action.toResult(transport(action.toRequest()))\n}\n</code></pre> <p>3 - Install KSP into Gradle, apply it, and create a KSP configuration using the http4k-connect KSP plugin in your module:</p> <pre><code>plugins {\n    kotlin(\"jvm\") \n    id(\"com.google.devtools.ksp\")\n}\n\napply(plugin = \"com.google.devtools.ksp\")\n\ndependencies {\n    implementation platform(\"org.http4k:http4k-connect-bom:5.22.1.0\")\n    ksp(\"org.http4k:http4k-connect-ksp-generator\")\n}\n</code></pre> <p>4 - And that's it! When Gradle runs, the following extension function will be generated:</p> <pre><code>fun API.reverse(value: String) = this(Reverse(value))\n</code></pre> <p>... which allows anyone to call it as if it was a standard method:</p> <pre><code>val api = API(JavaHttpClient())\n\nval result: Result&lt;String, RemoteFailure&gt; = api.reverse(\"hello\")\n</code></pre>"},{"location":"guide/reference/","title":"http4k Connect module overview","text":""},{"location":"guide/reference/#cloud_services","title":"Cloud Services","text":"Vendor System In-Memory Fake Notes AWS AppRunner \u2705 AWS CloudFront \u2705 AWS Cloudwatch Logs \u2705 AWS DynamoDb \u2705 AWS EventBridge \u2705 AWS Evidently \u2705 AWS Firehose \u2705 AWS IAM Identity Center \u2705 AWS Instance Metadata \u2705 AWS KMS \u2705 AWS Lambda \u2705 AWS S3 \u2705 AWS Secrets Manager \u2705 AWS SES \u2705 AWS SNS \u2705 AWS SQS \u2705 AWS STS \u2705 AWS Systems Manager \u2705 GitHub V3 API \u274c Client Shell and WebHook Signing only GitLab API \u274c Client Shell and WebHook Signing only Google Analytics GA4 \u2705 Google Analytics UA \u2705 Kafka Rest Proxy \u2705 Kafka Schema Registry \u2705 Mattermost WebHook \u274c"},{"location":"guide/reference/#ai_services","title":"AI Services","text":"Vendor System In-Memory Fake Notes AnthropicAI API \u2705 Includes content generators AzureAI API \u2705 Includes content generators and GitHubModels compatability LangChain4J Adapters \u274c Adapters to be plugged into LangChains LM Studio API \u2705 Ollama API \u2705 Includes content generators and image generation Open AI API \u2705 Includes content generators and image generation"},{"location":"guide/reference/#storage_implementations","title":"Storage Implementations","text":"Implementation Notes In-Memory Included with all Fakes File-Based Included with all Fakes JDBC Redis S3"},{"location":"guide/reference/ai/anthropic/","title":"AnthropicAI","text":""},{"location":"guide/reference/ai/anthropic/#installation","title":"Installation","text":"<pre><code>dependencies {\n    implementation(platform(\"org.http4k:http4k-connect-bom:5.22.1.0\"))\n    implementation(\"org.http4k:http4k-connect-ai-anthropic\")\n    implementation(\"org.http4k:http4k-connect-ai-anthropic-fake\")\n}\n</code></pre> <p>The http4k-connect AnthropicAI integration provides:</p> <ul> <li>AnthropicAI API Client</li> <li>FakeAnthropicAI server which can be used as testing harness for the API Client </li> </ul>"},{"location":"guide/reference/ai/anthropic/#anthropicai_api_connector","title":"AnthropicAI API connector","text":"<p>The AnthropicAI connector provides the following Actions:</p> <ul> <li> <p>MessageCompletion (streaming and non-streaming)</p> </li> <li> <p>New actions can be created easily using the same transport.</p> </li> </ul> <p>The client APIs utilise the AnthropicAI API Key. There is no reflection used anywhere in the library, so this is perfect for deploying to a Serverless function.</p>"},{"location":"guide/reference/ai/anthropic/#fake_anthropicai_server","title":"Fake AnthropicAI Server","text":"<p>The Fake AnthropicAI provides the below actions and can be spun up as a server, meaning it is perfect for using in test environments without using up valuable request tokens!</p> <ul> <li>MessageCompletion (streaming and non-streaming)</li> </ul>"},{"location":"guide/reference/ai/anthropic/#security","title":"Security","text":"<p>The Fake server endpoints are secured with a API key header, but the value is not checked for anything other than presence.</p>"},{"location":"guide/reference/ai/anthropic/#generation_of_responses","title":"Generation of responses","text":"<p>By default, a random LoremIpsum generator creates message completion responses for the Fake. This behaviour can be overridden to generate custom response formats (eg. structured responses) if required. To do so, create instances of the <code>MessageCompletionGenerator</code> interface and return as appropriate.</p>"},{"location":"guide/reference/ai/anthropic/#default_fake_port_18909","title":"Default Fake port: 18909","text":"<p>To start:</p> <pre><code>FakeAnthropicAI().start()\n</code></pre>"},{"location":"guide/reference/ai/azure/","title":"AzureAI","text":""},{"location":"guide/reference/ai/azure/#installation","title":"Installation","text":"<pre><code>dependencies {\n    implementation(platform(\"org.http4k:http4k-connect-bom:5.22.1.0\"))\n    implementation(\"org.http4k:http4k-connect-ai-azure\")\n    implementation(\"org.http4k:http4k-connect-ai-azure-fake\")\n}\n</code></pre> <p>The http4k-connect AzureAI integration provides:</p> <ul> <li>AzureAI API Client</li> <li>Compatibility with GitHub Models for testing, so you can use a GitHubToken instead of a deployed Azure model. Note that some endpoints are not available in GitHubModels APIs.</li> <li>FakeAzureAI server which can be used as testing harness for the API Client </li> </ul>"},{"location":"guide/reference/ai/azure/#azureai_api_connector","title":"AzureAI API connector","text":"<p>The AzureAI connector provides the following Actions:</p> <ul> <li>GetInfo</li> <li>ChatCompletions</li> <li>Completions</li> <li>CreateEmbeddings</li> </ul> <p>New actions can be created easily using the same transport.</p> <p>The client APIs utilise the AzureAI API Key (Bearer Auth). There is no reflection used anywhere in the library, so this is perfect for deploying to a Serverless function.</p>"},{"location":"guide/reference/ai/azure/#example_usage","title":"Example usage","text":"<pre><code>    // create a client\nval client = AzureAI.Http(\n    AzureAIApiKey.of(\"foobar\"),\n    AzureHost.of(\"myHost\"), Region.of(\"us-east-1\"),\n    http.debug()\n)\n\n// all operations return a Result monad of the API type\nval result: Result&lt;Sequence&lt;CompletionResponse&gt;, RemoteFailure&gt; = client\n    .chatCompletion(ModelName.of(\"Meta-Llama-3.1-70B-Instruct\"), listOf(Message.User(\"good afternoon\"))), 1000, true)\n\nprintln(result.orThrow().toList())\n}\n</code></pre> <p>Other examples can be found here.</p>"},{"location":"guide/reference/ai/azure/#fake_azureai_server","title":"Fake AzureAI Server","text":"<p>The Fake AzureAI provides the below actions and can be spun up as a server, meaning it is perfect for using in test environments without using up valuable request tokens!</p> <ul> <li>GetInfo</li> <li>ChatCompletions</li> <li>Completions</li> <li>CreateEmbeddings</li> </ul>"},{"location":"guide/reference/ai/azure/#security","title":"Security","text":"<p>The Fake server endpoints are secured with a BearerToken header, but the value is not checked for anything other than presence.</p>"},{"location":"guide/reference/ai/azure/#generation_of_responses","title":"Generation of responses","text":"<p>By default, a random LoremIpsum generator creates chat completion responses for the Fake. This behaviour can be overridden to generate custom response formats (eg. structured responses) if required. To do so, create instances of the <code>ChatCompletionGenerator</code> interface and return as appropriate.</p>"},{"location":"guide/reference/ai/azure/#default_fake_port_14504","title":"Default Fake port: 14504","text":"<p>To start:</p> <pre><code>FakeAzureAI().start()\n</code></pre>"},{"location":"guide/reference/ai/langchain/","title":"LangChain","text":""},{"location":"guide/reference/ai/langchain/#installation","title":"Installation","text":"<pre><code>dependencies {\n    implementation(platform(\"org.http4k:http4k-connect-bom:5.22.1.0\"))\n    implementation(\"org.http4k:http4k-connect-ai-langchain\")\n}\n</code></pre> <p>LangChain4J is a versatile library that simplifies the creation and management of language processing workflows., It provides many integrations but does not allow for using http4k clients or http4k-connect clients. This module gives you some of these integrations by providing LangChain model adapters.</p> <p>Current adapters support http4k client integrations for the following models, allowing you to use them in your http4k applications:</p> <ul> <li>OpenAI</li> <li>OpenAiChatLanguageModel</li> <li>OpenAiChatImageModel</li> <li>OpenAiChatEmbeddingModel</li> <li>Ollama</li> <li>OllamaChatLanguageModel</li> <li>OllamaChatImageModel</li> <li>OllamaChatEmbeddingModel</li> <li>S3 Document Loaders</li> </ul> <p>Using these adapters is as simple as:</p> <pre><code>val model: ChatLanguageModel = OpenAiChatLanguageModel(OpenAI.Http(OpenAIToken.of(\"hello\"), FakeOpenAI()))\nval chat: Response&lt;AiMessage&gt; = model.generate(\"hello kitty\")\n</code></pre>"},{"location":"guide/reference/ai/lmstudio/","title":"LmStudio","text":""},{"location":"guide/reference/ai/lmstudio/#installation","title":"Installation","text":"<pre><code>dependencies {\n    implementation(platform(\"org.http4k:http4k-connect-bom:5.22.1.0\"))\n    implementation(\"org.http4k:http4k-connect-ai-lmstudio\")\n    implementation(\"org.http4k:http4k-connect-ai-lmstudio-fake\")\n}\n</code></pre> <p>The http4k-connect LmStudio integration provides:</p> <ul> <li>LmStudio API Client</li> <li>FakeLmStudio server which can be used as testing harness for either API Client</li> </ul>"},{"location":"guide/reference/ai/lmstudio/#lmstudio_api_connector","title":"LmStudio API connector","text":"<p>The LmStudio connector provides the following Actions:</p> <ul> <li>GetModels</li> <li>ChatCompletion</li> <li>CreateEmbeddings</li> </ul> <p>New actions can be created easily using the same transport.</p> <p>The client APIs utilise the LmStudio API Key (Bearer Auth). There is no reflection used anywhere in the library, so this is perfect for deploying to a Serverless function.</p>"},{"location":"guide/reference/ai/lmstudio/#example_usage","title":"Example usage","text":"<pre><code>const val USE_REAL_CLIENT = false\n\nfun main() {\n    // we can connect to the real service or the fake (drop in replacement)\n    val http: HttpHandler = if (USE_REAL_CLIENT) JavaHttpClient() else FakeLmStudio()\n\n    // create a client\n    val client = LmStudio.Http(http.debug())\n\n    // all operations return a Result monad of the API type\n    val result: Result&lt;Models, RemoteFailure&gt; = client\n        .getModels()\n\n    println(result)\n}\n</code></pre> <p>Other examples can be found here.</p>"},{"location":"guide/reference/ai/lmstudio/#fake_lmstudio_server","title":"Fake LmStudio Server","text":"<p>The Fake LmStudio provides the below actions and can be spun up as a server, meaning it is perfect for using in test environments without using up valuable request tokens!</p> <ul> <li>GetModels</li> <li>ChatCompletion</li> </ul>"},{"location":"guide/reference/ai/lmstudio/#generation_of_responses","title":"Generation of responses","text":"<p>By default, a random LoremIpsum generator creates chat completion responses for the Fake. This behaviour can be overridden to generate custom response formats (eg. structured responses) if required. To do so, create instances of the <code>ChatCompletionGenerator</code> interface and return as appropriate.</p>"},{"location":"guide/reference/ai/lmstudio/#default_fake_port_58438","title":"Default Fake port: 58438","text":"<p>To start:</p> <pre><code>FakeLmStudio().start()\n</code></pre>"},{"location":"guide/reference/ai/ollama/","title":"Ollama","text":""},{"location":"guide/reference/ai/ollama/#installation","title":"Installation","text":"<pre><code>dependencies {\n    implementation(platform(\"org.http4k:http4k-connect-bom:5.22.1.0\"))\n    implementation(\"org.http4k:http4k-connect-ai-ollama\")\n    implementation(\"org.http4k:http4k-connect-ai-ollama-fake\")\n}\n</code></pre> <p>The http4k-connect Ollama integration provides: - Ollama API Client - FakeOllama server which can be used as testing harness </p>"},{"location":"guide/reference/ai/ollama/#ollama_api_connector","title":"Ollama API connector","text":"<p>The Ollama connector provides the following Actions:</p> <ul> <li>GetModels</li> <li>ChatCompletion</li> <li>CreateEmbeddings</li> <li>GenerateImage</li> </ul> <p>New actions can be created easily using the same transport.</p> <p>The client APIs utilise the Ollama API Key (Bearer Auth). There is no reflection used anywhere in the library, so this is perfect for deploying to a Serverless function.</p>"},{"location":"guide/reference/ai/ollama/#example_usage","title":"Example usage","text":"<pre><code>const val USE_REAL_CLIENT = false\n\nfun main() {\n    // we can connect to the real service or the fake (drop in replacement)\n    val http: HttpHandler = if (USE_REAL_CLIENT) JavaHttpClient() else FakeOllama()\n\n    // create a client\n    val client = Ollama.Http(http.debug())\n\n    // all operations return a Result monad of the API type\n    val result: Result&lt;ModelList, RemoteFailure&gt; = client.getModels()\n\n    println(result)\n}\n</code></pre> <p>Other examples can be found here.</p>"},{"location":"guide/reference/ai/ollama/#fake_ollama_server","title":"Fake Ollama Server","text":"<p>The Fake Ollama provides the below actions and can be spun up as a server, meaning it is perfect for using in test environments without using up valuable request tokens!</p> <ul> <li>GetModels</li> <li>ChatCompletion</li> <li>Completion</li> <li>PullModel</li> <li>CreateEmbeddings</li> </ul>"},{"location":"guide/reference/ai/ollama/#generation_of_responses","title":"Generation of responses","text":"<p>By default, a random LoremIpsum generator creates chat completion responses for the Fake. This behaviour can be overridden to generate custom response formats (eg. structured responses) if required. To do so, create instances of the <code>ChatCompletionGenerator</code> interface and return as appropriate.</p>"},{"location":"guide/reference/ai/ollama/#default_fake_port_31193","title":"Default Fake port: 31193","text":"<p>To start:</p> <pre><code>FakeOllama().start()\n</code></pre>"},{"location":"guide/reference/ai/openai/","title":"OpenAI","text":""},{"location":"guide/reference/ai/openai/#installation","title":"Installation","text":"<pre><code>dependencies {\n    implementation(platform(\"org.http4k:http4k-connect-bom:5.22.1.0\"))\n    implementation(\"org.http4k:http4k-connect-ai-openai\")\n    implementation(\"org.http4k:http4k-connect-ai-openai-fake\")\n}\n</code></pre> <p>The http4k-connect OpenAI integration provides: - OpenAI API Client - Plugin SDK for developing OpenAI plugins - FakeOpenAI server which can be used as testing harness for either API Client or OpenAI plugins</p>"},{"location":"guide/reference/ai/openai/#openai_api_connector","title":"OpenAI API connector","text":"<p>The OpenAI connector provides the following Actions:</p> <ul> <li>GetModels</li> <li>ChatCompletion</li> <li>CreateEmbeddings</li> <li>GenerateImage</li> </ul> <p>New actions can be created easily using the same transport.</p> <p>The client APIs utilise the OpenAI API Key (Bearer Auth). There is no reflection used anywhere in the library, so this is perfect for deploying to a Serverless function.</p>"},{"location":"guide/reference/ai/openai/#example_usage","title":"Example usage","text":"<pre><code>const val USE_REAL_CLIENT = false\n\nfun main() {\n    // we can connect to the real service or the fake (drop in replacement)\n    val http: HttpHandler = if (USE_REAL_CLIENT) JavaHttpClient() else FakeOpenAI()\n\n    // create a client\n    val client = OpenAI.Http(OpenAIToken.of(\"foobar\"), http.debug())\n\n    // all operations return a Result monad of the API type\n    val result: Result&lt;Models, RemoteFailure&gt; = client\n        .getModels()\n\n    println(result)\n}\n</code></pre> <p>Other examples can be found here.</p>"},{"location":"guide/reference/ai/openai/#openai_plugin_sdk","title":"OpenAI Plugin SDK","text":"<p>The OpenAPI Plugin SDK provides APIs to simply write OpenAI compliant plugins with the minimum of fuss. Simply  use the <code>openAiPlugin()</code> function to compose your function, adding the configuration for the authorization and  the contract endpoints which expose the API to OpenAI. </p> <p>The following plugin types are supported: - Service - the Plugin developer provides credentials to the OpenAI UI which are used for auth. No personalisation  of responses is possible. - User - the OpenAI user provides credentials to the OpenAI UI which are used for auth. Prinicpals are tracked so the API responses can be personalised. - OAuth - users login to the Plugin application using an AuthorizationCode grant and an experience defined by the  Plugin developer.</p> <p>The SDK provides all features required by the OpenAI platform: - A manifest endpoint for the plugin, with all of the required configuration  - An OpenAPI specification endpoint for OpenAI to interrogate your API - Security on the API endpoints as defined on construction. Supported auth methods are:   - Basic Auth   - Bearer Auth   - OAuth (Authorization flow) - with security endpoints. </p> <p>Plugins are just <code>HttpHandlers</code> and as such can be mixed into existing applications or started alone. Example:</p> <pre><code> openAiPlugin(\n        info(\n            apiVersion = \"1.0\",\n            humanDescription = \"addressbook\" to \"my great plugin\",\n            pluginUrl = Uri.of(\"http://localhost:9000\"),\n            contactEmail = Email.of(\"foo@bar\"),\n        ),\n        UserLevelAuth(\n            PluginAuthToken.Basic(\"realm\") { it: Credentials -&gt; it == credentials }\n        ),\n        Path.of(\"foo\") / Path.of(\"bar\") meta {\n            summary = \"A great api endpoint\"\n        } bindContract GET to\n            { foo, bar -&gt;\n                { _: Request -&gt; Response(OK).with(Body.auto&lt;Message&gt;().toLens() of Message(\"hello $foo $bar\")) }\n            }\n    )\n</code></pre> <p>The FakeOpenAI server also provides support for running plugins locally and interacting with them as \"installed\" in the fake.</p> <p>There is a full working example of how to create and deploy plugins in the examples repository.</p>"},{"location":"guide/reference/ai/openai/#fake_openai_server","title":"Fake OpenAI Server","text":"<p>The Fake OpenAI provides the below actions and can be spun up as a server, meaning it is perfect for using in test environments without using up valuable request tokens!</p> <ul> <li>GetModels</li> <li>ChatCompletion</li> <li>GenerateImage</li> </ul>"},{"location":"guide/reference/ai/openai/#security","title":"Security","text":"<p>The Fake server endpoints are secured with a BearerToken header, but the value is not checked for anything other than presence.</p>"},{"location":"guide/reference/ai/openai/#image_generation","title":"Image generation","text":"<p>Image generation also can be set to either URL or base-64 data return. In the case of URLs, the Fake also doubles as a webserver for serving the images (so you can request an image and then load it from the server). Resolution PNG images of 256x/512x/1024x are supported.</p>"},{"location":"guide/reference/ai/openai/#generation_of_responses","title":"Generation of responses","text":"<p>By default, a random LoremIpsum generator creates chat completion responses for the Fake. This behaviour can be overridden to generate custom response formats (eg. structured responses) if required. To do so, create instances of the <code>ChatCompletionGenerator</code> interface and return as appropriate.</p>"},{"location":"guide/reference/ai/openai/#running_plugins_in_the_fakeopenai","title":"Running plugins in the FakeOpenAI","text":"<p>http4k-connect OpenAI Plugins can be run locally and also \"installed\" into the FakeOpenAI. To install a plugin, pass the configured <code>PluginIntegration</code> instances into the fake at construction time. The FakeOpenAI will then  use the configuration to negotiate the connection to the plugin. Both the Fake and the Plugin should be running  on different local ports.</p> <pre><code> FakeOpenAI(\n        plugins = arrayOf(\n            ServicePluginIntegration(\n                BearerAuth(\"openai api key\"),\n                OpenAIPluginId.of(\"serviceplugin\"),\n                Uri.of(\"http://localhost:10000\")\n            )\n        )\n    ).start()\n</code></pre> <p>To test the Plugin locally, start and browse to the FakeOpenAI instance. The list of installed plugins will  be displayed and can be clicked through to an authenticated OpenAPI UI which can be used to interact with the  exposed Plugin API.</p>"},{"location":"guide/reference/ai/openai/#default_fake_port_45674","title":"Default Fake port: 45674","text":"<p>To start:</p> <pre><code>FakeOpenAI().start()\n</code></pre>"},{"location":"guide/reference/amazon/","title":"AWS Overview Guide","text":"<p>http4k-connect provides a standardised mechanism to connect to several AWS services. They all use the same mechanisms for authentication, which is what this page is about.</p>"},{"location":"guide/reference/amazon/#auth","title":"Auth","text":"<p>Authing into AWS services is possible with a few different mechanisms based on the environmental variables passed to your app. Under the covers, there is a <code>CredentialProvider</code> implementation which is switchable depending on your use-case:</p>"},{"location":"guide/reference/amazon/#static_aws_accesskeysecret_authorisation_uses","title":"Static AWS AccessKey/Secret authorisation uses:","text":"<ul> <li>AWS_REGION</li> <li>AWS_ACCESS_KEY_ID</li> <li>AWS_SECRET_ACCESS_KEY</li> <li>AWS_SESSION_TOKEN</li> </ul> <p>This is the default mechanism, so no special action is required:</p> <pre><code>val sqs = SQS.Http()\n</code></pre>"},{"location":"guide/reference/amazon/#sts_authorisation_uses","title":"STS authorisation uses:","text":"<ul> <li>AWS_REGION</li> <li>AWS_ACCESS_KEY_ID</li> <li>AWS_SECRET_ACCESS_KEY</li> <li>AWS_SESSION_TOKEN</li> </ul> <p>This auth method uses the STS <code>AssumeRole</code> action to retrieve the rotating credentials from STS using auth from the environmental variables. This requires overriding the credentials provider used when constructing the client:</p> <pre><code>val sqs = SQS.Http(credentialsProvider = CredentialsProvider.STS())\n</code></pre>"},{"location":"guide/reference/amazon/#sts_webidentity_authorisation_uses","title":"STS WebIdentity authorisation uses:","text":"<ul> <li>AWS_ROLE_ARN</li> <li>AWS_WEB_IDENTITY_TOKEN_FILE</li> </ul> <p>This auth method uses the STS <code>AssumeRoleWithWebIdentity</code> action to retrieve the rotating credentials from STS using the Web Identity JWT from the file path contained in the env variable. This requires overriding the credentials provider used when constructing the client:</p> <pre><code>val sqs = SQS.Http(credentialsProvider = CredentialsProvider.STSWebIdentity())\n</code></pre>"},{"location":"guide/reference/amazon/apprunner/","title":"AppRunner","text":""},{"location":"guide/reference/amazon/apprunner/#installation","title":"Installation","text":"<pre><code>dependencies {\n    implementation(platform(\"org.http4k:http4k-connect-bom:5.22.1.0\"))\n    implementation(\"org.http4k:http4k-connect-amazon-apprunner\")\n    implementation(\"org.http4k:http4k-connect-amazon-apprunner-fake\")\n}\n</code></pre> <p>The AppRunner connector provides the following Actions:</p> <pre><code> *  CreateService\n *  DeleteService\n *  ListServices\n</code></pre>"},{"location":"guide/reference/amazon/apprunner/#example_usage","title":"Example usage","text":"<pre><code>const val USE_REAL_CLIENT = false\n\nfun main() {\n    val deployedLambda = FunctionName(\"http4kLambda\")\n\n    val fakeAppRunner = FakeAppRunner(\n    )\n\n    // we can connect to the real service or the fake (drop in replacement)\n    val http: HttpHandler = if (USE_REAL_CLIENT) JavaHttpClient() else fakeAppRunner\n\n    // create a client\n    val client = AppRunner.Http(Region.of(\"us-east-1\"), { AwsCredentials(\"accessKeyId\", \"secretKey\") }, http.debug())\n\n    // all operations return a Result monad of the API type\n    println(client.listServices())\n}\n</code></pre> <p>The client APIs utilise the <code>http4k-aws</code> module for request signing, which means no dependencies on the incredibly fat Amazon-SDK JARs. This means this integration is perfect for running Serverless Lambdas where binary size is a performance factor.</p>"},{"location":"guide/reference/amazon/apprunner/#default_fake_port_62628","title":"Default Fake port: 62628","text":"<p>To start:</p> <pre><code>FakeAppRunner().start()\n</code></pre>"},{"location":"guide/reference/amazon/cloudfront/","title":"CloudFront","text":""},{"location":"guide/reference/amazon/cloudfront/#installation","title":"Installation","text":"<pre><code>dependencies {\n    implementation(platform(\"org.http4k:http4k-connect-bom:5.22.1.0\"))\n    implementation(\"org.http4k:http4k-connect-amazon-cloudfront\")\n    implementation(\"org.http4k:http4k-connect-amazon-cloudfront-fake\")\n}\n</code></pre> <p>The CloudFront connector provides the following Actions:</p> <pre><code> *  CreateInvalidation\n</code></pre> <p>The client APIs utilise the <code>http4k-aws</code> module for request signing, which means no dependencies on the incredibly fat Amazon-SDK JARs. This means this integration is perfect for running Serverless Lambdas where binary size is a performance factor.</p>"},{"location":"guide/reference/amazon/cloudfront/#example_usage","title":"Example usage","text":"<pre><code>const val USE_REAL_CLIENT = false\n\nfun main() {\n    // we can connect to the real service or the fake (drop in replacement)\n    val http: HttpHandler = if (USE_REAL_CLIENT) JavaHttpClient() else FakeCloudFront()\n\n    // create a client\n    val client =\n        CloudFront.Http({ AwsCredentials(\"accessKeyId\", \"secretKey\") }, http.debug())\n\n    // all operations return a Result monad of the API type\n    val result: Result&lt;Unit, RemoteFailure&gt; = client\n        .createInvalidation(DistributionId.of(\"a-distribution-id\"), listOf(\"/path\"), 1, random())\n}\n</code></pre>"},{"location":"guide/reference/amazon/cloudfront/#default_fake_port_15420","title":"Default Fake port: 15420","text":"<p>To start:</p> <pre><code>FakeCloudFront().start()\n</code></pre>"},{"location":"guide/reference/amazon/cloudwatchlogs/","title":"CloudWatchLogs","text":""},{"location":"guide/reference/amazon/cloudwatchlogs/#installation","title":"Installation","text":"<pre><code>dependencies {\n    implementation(platform(\"org.http4k:http4k-connect-bom:5.22.1.0\"))\n    implementation(\"org.http4k:http4k-connect-amazon-cloudwatchlogs\")\n    implementation(\"org.http4k:http4k-connect-amazon-cloudwatchlogs-fake\")\n}\n</code></pre> <p>The CloudWatchLogs connector provides the following Actions:</p> <ul> <li>CreateLogGroup</li> <li>CreateLogStream</li> <li>DeleteLogGroup</li> <li>DeleteLogStream</li> <li>FilterLogEvents</li> <li>PutLogEvents</li> </ul> <p>The client APIs utilise the <code>http4k-aws</code> module for request signing, which means no dependencies on the incredibly fat Amazon-SDK JARs. This means this integration is perfect for running Serverless Lambdas where binary size is a performance factor.</p>"},{"location":"guide/reference/amazon/cloudwatchlogs/#example_usage","title":"Example usage","text":"<pre><code>const val USE_REAL_CLIENT = false\n\nval http: HttpHandler = if (USE_REAL_CLIENT) JavaHttpClient() else FakeCloudWatchLogs()\n\n// creatxe a client\nval cloudWatchLogs =\n    CloudWatchLogs.Http(Region.US_EAST_1, { AwsCredentials(\"accessKeyId\", \"secretKey\") }, http.debug())\n\nval result: Result&lt;PutLogEventsResponse, RemoteFailure&gt; = cloudWatchLogs.putLogEvents(\n    LogGroupName.of(\"foobar\"),\n    LogStreamName.of(\"stream\"),\n    emptyList()\n)\n\nprintln(result)\n</code></pre>"},{"location":"guide/reference/amazon/cloudwatchlogs/#default_fake_port_56514","title":"Default Fake port: 56514","text":"<p>To start:</p> <pre><code>FakeCloudWatchLogs().start()\n</code></pre>"},{"location":"guide/reference/amazon/cognito/","title":"Cognito","text":""},{"location":"guide/reference/amazon/cognito/#installation","title":"Installation","text":"<pre><code>dependencies {\n    implementation(platform(\"org.http4k:http4k-connect-bom:5.22.1.0\"))\n    implementation(\"org.http4k:http4k-connect-amazon-cognito\")\n    implementation(\"org.http4k:http4k-connect-amazon-cognito-fake\")\n}\n</code></pre> <p>The Cognito connector provides the following Actions:</p> <ul> <li>AdminCreateUser</li> <li>AdminDeleteUser</li> <li>AdminDisableUser</li> <li>AdminEnableUser</li> <li>AdminGetUser</li> <li>AdminResetUserPassword</li> <li>AdminSetUserPassword</li> <li>AssociateSoftwareToken</li> <li>ConfirmForgotPassword</li> <li>CreateResourceServer</li> <li>CreateUserPool</li> <li>CreateUserPoolClient</li> <li>CreateUserPoolDomain</li> <li>DeleteUserPool</li> <li>DeleteUserPoolClient</li> <li>DeleteUserPoolDomain</li> <li>ForgotPassword</li> <li>GetJwks</li> <li>ListUserPools</li> <li>InitiateAuth</li> <li>RespondToAuthChallenge</li> <li>VerifySoftwareToken</li> </ul>"},{"location":"guide/reference/amazon/cognito/#fake","title":"# Fake","text":"<p>The Cognito Fake has very limited functionality for creating User Pools and User Pool Clients only. It can act as an OAuthServer for created User Pool Clients. It supports the ClientCredentials and Authorization Code grants and returns JWTs which have been signed with a private key. The matching public key can be retrieved from the following endpoint:</p> <p><code>http://&lt;server:port&gt;/&lt;user pool id&gt;/.well-known/jwks.json</code></p> <p>Note that there are 2 keys returned by the JWKs endpoint - the first is \"expired\" and not used, the second is the one used to sign the JWTs.</p>"},{"location":"guide/reference/amazon/cognito/#default_fake_port_37192","title":"Default Fake port: 37192","text":"<p>To start:</p> <pre><code>FakeCloudFront().start()\n</code></pre>"},{"location":"guide/reference/amazon/containercredentials/","title":"Container Credentials","text":""},{"location":"guide/reference/amazon/containercredentials/#installation","title":"Installation","text":"<pre><code>dependencies {\n    implementation(platform(\"org.http4k:http4k-connect-bom:5.22.1.0\"))\n    implementation(\"org.http4k:http4k-connect-amazon-containercredentials\")\n    implementation(\"org.http4k:http4k-connect-amazon-containercredentials-fake\")\n}\n</code></pre> <p>The Container Credentials connector provides the following Actions:</p> <pre><code> *  GetCredentials\n</code></pre> <p>The client APIs utilise the <code>http4k-aws</code> module for request signing, which means no dependencies on the incredibly fat Amazon-SDK JARs. This means this integration is perfect for running Serverless Lambdas where binary size is a performance factor.</p>"},{"location":"guide/reference/amazon/containercredentials/#default_fake_port_63556","title":"Default Fake port: 63556","text":"<p>To start:</p> <pre><code>FakeContainerCredentials().start()\n</code></pre>"},{"location":"guide/reference/amazon/dynamodb/","title":"DynamoDb","text":""},{"location":"guide/reference/amazon/dynamodb/#installation","title":"Installation","text":"<pre><code>dependencies {\n    implementation(platform(\"org.http4k:http4k-connect-bom:5.22.1.0\"))\n    implementation(\"org.http4k:http4k-connect-amazon-dynamodb\")\n    implementation(\"org.http4k:http4k-connect-amazon-dynamodb-fake\")\n}\n</code></pre> <p>The DynamoDb connector provides the following Actions:</p> <pre><code>* CreateTable\n* DeleteTable\n* DescribeTable\n* ListTables\n* UpdateTable\n* DeleteItem\n* GetItem\n* PutItem\n* Query\n* Scan\n* UpdateItem\n* TransactGetItems\n* TransactWriteItems\n* BatchGetItem\n* BatchWriteItem\n* ExecuteTransaction\n* ExecuteStatement\n* BatchExecuteStatement\n</code></pre> <p>Note that the FakeDynamo supports the majority of the Dynamo operations with the following exceptions. You can use DynamoDB local instead to provide these functions:</p> <pre><code>* BatchExecuteStatement\n* ExecuteStatement\n* ExecuteTransaction\n</code></pre> <p>The client APIs utilise the <code>http4k-aws</code> module for request signing, which means no dependencies on the incredibly fat Amazon-SDK JARs. This means this integration is perfect for running Serverless Lambdas where binary size is a performance factor.</p>"},{"location":"guide/reference/amazon/dynamodb/#typesafe_items_keys","title":"Typesafe Items &amp; Keys","text":"<p>Most of the http4k-connect DynamoDb API is fairly simple, but one addition which may warrant further explanation is the http4k Lens system which is layered on top provide a typesafe API to the Item/Key objects (used for getting/setting record attributes and for defining key structures). This is useful because of the unique way in which Dynamo handles the structure of the stored items.</p> <ul> <li><code>AttributeName</code> - is just a data class for a named attribute in an item/key</li> <li><code>AttributeValue</code> is the on-the-wire format of an attribute with it's requisite type. Examples of this are: <code>{ \"S\": \"hello\" }</code> or <code>{ \"BOOL\": true }</code> or <code>{ \"NS\": [\"123\"] }</code>. Construction of these AttributeValues can be done using factory functions such as <code>AttributeValue.Str(\"string\")</code>. <code>AttributeValues</code> can be primitives (BOOL, S, N), Sets (NS, BS), or collections of other AttributeValues (L, M).</li> <li><code>Item</code> and <code>Key</code> are just typealiases for <code>Map&lt;AttributeName, AttributeValue&gt;</code>. They have convenience construction methods <code>Item()</code> and <code>Key()</code>. These are sent to and returned in the messages between a client and DynamoDb.</li> </ul> <p>When constructing <code>Actions</code> or deconstructing their responses for Items/Keys, we can populate or interrogate the Map returned manually, but we may be unsure of the types. To that end, the http4k Lens system has been used to create a typesafe binding between the names and types of the AttributeValues. This system supports all of types available in the Dynamo type system, and also provides mapping for both common JDK types (including popular Java Datetime types) and required/optional attributes (ie. <code>String</code> vs <code>String?</code>).</p>"},{"location":"guide/reference/amazon/dynamodb/#typesafe_lens-based_dynamo_object_mapper","title":"Typesafe lens-based Dynamo Object Mapper","text":"<p>Using the lens system and http4k automapping facilities, http4k-connect also supports dynamic flattening of objects into the DynamoDB schema with zero boilerplate. Simply create a lens and apply it to your object to inject values into the DynamoDB Item. the structure of maps and lists are preserved by collapsing them into a single DynamoDB field. This is implemented as a standard extension function on any of the http4k automarshalling object mappers (Jackson, Moshi, GSON etc..):</p> <pre><code>data class AnObject(val str: String, val num: Int)\n\nval input = AnObject(\"foobar\", 123)\n\nval lens = Moshi.autoDynamoLens&lt;AnObject&gt;()\n\nval item: Item = Item().with(lens of input)\n\nval extracted: AnObject = lens(item)\n</code></pre>"},{"location":"guide/reference/amazon/dynamodb/#example","title":"Example","text":"<p>Given that a record in Dynamo will have many typed values, we first define a set of attributes which are relevant for the case in question. These methods construct Lenses which can be used to inject or extract typed values safely:</p> <pre><code>val attrS = Attribute.string().optional(\"theNull\")\nval attrBool = Attribute.boolean().required(\"theBool\")\nval attrN = Attribute.int().optional(\"theNum\")\nval attrI = Attribute.instant().required(\"theInstant\")\nval attrM = Attribute.map().required(\"theMap\")\n</code></pre> <p>To construct an Item or Key to send to Dynamo, we can bind the values at the same time:</p> <pre><code>val item = Item(\n    attrS of \"hello\",\n    attrN of null,\n    attrM of Item(attrI of Instant.now())\n)\n</code></pre> <p>To deconstruct an Item or Key to send to Dynamo, we simply apply the attributes as functions to the container:</p> <pre><code>val string: String? = attrS(item)\nval boolean: Boolean = attrBool(item)\nval instant: Instant = attrI(attrM(item))\n</code></pre> <p>On missing or invalid value, an exception is thrown. To counter this we can use the built in Result4k monad marshalling: </p> <pre><code>val boolean: Result&lt;Boolean, LensFailure&gt; = attrBool.asResult()(item)\n</code></pre> <p>It is also possible to <code>map()</code> lenses to provide marshalling into your own types.</p>"},{"location":"guide/reference/amazon/dynamodb/#null_handling_and_sparse_indexes","title":"Null handling and sparse indexes","text":"<p>The default mapping for null values of manually mapped optional attributes in DynamoDB will assign them to an explicit  null attribute:</p> <pre><code>val attrS = Attribute.string().optional(\"optS\")\nval item = Item(attrS of null)\n\n// item now contains \"optS\": { \"NULL\": true }\n</code></pre> <p>When utilizing an optional attribute as a key in a secondary index (creating a sparse index), the attribute must be  absent rather than null. To achieve this, set <code>ignoreNull</code> to true in the attribute definition.</p> <pre><code>val attrS = Attribute.string().optional(\"optS\", ignoreNull = true)\n</code></pre> <p>When incorporating this attribute into the secondary index schema, it is necessary to convert it into a mandatory  (non-optional) attribute.</p> <pre><code>// attrS is of type Attribute&lt;String?&gt;\n\nattrS.asRequired() // will be of type Attribute&lt;String&gt;\n</code></pre> <p>Note: null properties of automapped objects (using <code>autoDynamoLens()</code>) will be ignored by default.</p>"},{"location":"guide/reference/amazon/dynamodb/#dynamodb_table_repository","title":"DynamoDB Table Repository","text":"<p>A simplified API for mapping documents to and from a single table with <code>get</code>, <code>put</code>, <code>scan</code>, <code>query</code>, etc.</p> <pre><code>private const val USE_REAL_CLIENT = false\n\n// define our data class\nprivate data class Person(\n    val name: String,\n    val id: UUID = UUID.randomUUID()\n)\n\nprivate val john = Person(\"John\")\nprivate val jane = Person(\"Jane\")\n\nfun main() {\n    // build client (real or fake)\n    val http = if (USE_REAL_CLIENT) JavaHttpClient() else FakeDynamoDb()\n    val dynamoDb = DynamoDb.Http(Region.CA_CENTRAL_1, { AwsCredentials(\"id\", \"secret\") }, http.debug())\n\n    // defined table mapper\n    val table = dynamoDb.tableMapper&lt;Person, UUID, Unit&gt;(\n        tableName = TableName.of(\"people\"),\n        hashKeyAttribute = Attribute.uuid().required(\"id\")\n    )\n\n    // create table\n    table.createTable()\n\n    // save\n    table.save(john)\n    table.save(jane)\n\n    // get\n    val johnAgain = table.get(john.id)\n\n    // scan\n    val people = table.primaryIndex().scan().take(10)\n\n    // delete\n    table.delete(john)\n}\n</code></pre> <p>See another example with secondary indices.</p> <p>Complex scan or query expressions may be constructed using functions from the <code>KeyConditionBuilder</code> and <code>FilterExpressionBuilder</code> classes (which therefore provide a scan/query DSL). This DSL is not complete, however it should cover most of the common use cases. </p> <p>Examples:</p> <pre><code>val idAttr = Attribute.uuid().required(\"id\")\nval nameAttr = Attribute.string().required(\"name\")\n\n// scan with filter\nval people = table.primaryIndex().scan {\n    filterExpression {\n        (nameAttr beginsWith \"J\") and not(nameAttr eq \"Jimmy\")\n    }\n}\n\n// query with key condition (doesn't actually make much sense is this example)\nval anotherJohn = table.primaryIndex().query {\n    keyCondition {\n        hashKey eq john.id\n    }\n}\n</code></pre> <p>General query pattern with combined key condition and filter expression</p> <pre><code>table.primaryIndex().query {\n    keyCondition {\n        (hashKey eq hashValue) and (sortKey gt sortValue)\n    }\n    filterExpression {\n        (fooAttr ne \"foo\") or (barAttr isIn listOf(5, 6, 7)) and (bazAttr lt quzAttr)\n    }\n}\n</code></pre> <p>Notes:  - <code>hashKey</code> and <code>sortKey</code> are special identifiers to be used in the <code>keyCondition</code> that represent the actual key     attributes of the current index  - the hash key condition must use the <code>eq</code> operator (no other operators allowed),  - in the sort key condition the following operators are supported: <code>eq</code> <code>gt</code>,<code>ge</code>,<code>lt</code>, <code>le</code> (for <code>=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code>),     <code>beginsWith</code>, and the <code>sortKey.between(val1, val2)</code> function  - in the filter expression concrete attributes must be used instead of <code>hashKey</code> or <code>sortKey</code>  - the filter expression supports all of the above operators plus <code>ne</code> (<code>&lt;&gt;</code>), <code>isIn</code>, <code>contains</code>, <code>attributeExists(attr)</code>,    and <code>attributeNotExists(attr)</code>  - in a filter expression the first operand in a comparison must be an attribute, the second operand is either a value    or another attribute of the same type (so <code>xAttr eq 42</code> and <code>xAttr ne yAttr</code> are supported, but <code>42 eq xAttr</code> is not)   - the logical operators <code>and</code> and <code>or</code> in this DSL are always evaluated from left to right (i.e. there is no higher precedence for <code>and</code>),    you should use parenthesis to change the order of evaluation   - if an operand of a logical operator is <code>null</code> it will simply be omitted. This allows building queries with optional conditions:</p> <pre><code>filterExpression {\n   val nameFilter = name?.let { nameAttr eq it }\n   val sizeFilter = size?.let { sizeAttr eq it }\n\n   // results in either a filter for name, a filter for size, a filter for both, or in no filter at all \n   nameFilter and sizeFilter \n}\n</code></pre>"},{"location":"guide/reference/amazon/dynamodb/#general_example_usage_of_api_client","title":"General example usage of API Client","text":"<pre><code>// we can connect to the real service\nval http: HttpHandler = JavaHttpClient()\n\n// create a client\nval client = DynamoDb.Http(Region.of(\"us-east-1\"), { AwsCredentials(\"accessKeyId\", \"secretKey\") }, http.debug())\n\nval table = TableName.of(\"myTable\")\n\n// we can bind values to the attributes\nclient.putItem(\n    table,\n    Item = mapOf(\n        attrS to \"foobar\",\n        attrBool to true,\n        attrB to Base64Blob.encode(\"foo\"),\n        attrBS to setOf(Base64Blob.encode(\"bar\")),\n        attrN to 123,\n        attrNS to setOf(123, 12.34),\n        attrL to listOf(\n            List(listOf(AttributeValue.Str(\"foo\"))),\n            Num(123),\n            Null()\n        ),\n        attrM to mapOf(attrS to \"foo\", attrBool to false),\n        attrSS to setOf(\"345\", \"567\"),\n        attrNL to null\n    )\n)\n\n// lookup an item from the database\nval item = client.getItem(table, key = mapOf(attrS to \"hello\")).valueOrNull()!!.item!!\nval str: String? = attrS(item)\n\n// all operations return a Result monad of the API type\nval deleteResult: Result&lt;TableDescriptionResponse, RemoteFailure&gt; = client.deleteTable(table)\nprintln(deleteResult)\n</code></pre>"},{"location":"guide/reference/amazon/eventbridge/","title":"EventBridge","text":""},{"location":"guide/reference/amazon/eventbridge/#installation","title":"Installation","text":"<pre><code>dependencies {\n    implementation(platform(\"org.http4k:http4k-connect-bom:5.22.1.0\"))\n    implementation(\"org.http4k:http4k-connect-amazon-eventbridge\")\n    implementation(\"org.http4k:http4k-connect-amazon-eventbridge-fake\")\n}\n</code></pre> <p>The EventBridge connector provides the following Actions:      *  CreateEventBus      *  DeleteEventBus      *  DescribeEventBus      *  PutEvents</p>"},{"location":"guide/reference/amazon/eventbridge/#example_usage","title":"Example usage","text":"<p>The client APIs utilise the <code>http4k-aws</code> module for request signing, which means no dependencies on the incredibly fat Amazon-SDK JARs. This means this integration is perfect for running Serverless Lambdas where binary size is a performance factor.</p>"},{"location":"guide/reference/amazon/eventbridge/#default_fake_port_13577","title":"Default Fake port: 13577","text":"<p>To start:</p> <pre><code>FakeEventBridge().start()\n</code></pre>"},{"location":"guide/reference/amazon/evidently/","title":"Cloudwatch Evidently","text":""},{"location":"guide/reference/amazon/evidently/#installation","title":"Installation","text":"<pre><code>dependencies {\n    implementation(platform(\"org.http4k:http4k-connect-bom:5.22.1.0\"))\n    implementation(\"org.http4k:http4k-connect-amazon-evidently\")\n    implementation(\"org.http4k:http4k-connect-amazon-evidently-fake\")\n}\n</code></pre> <p>The Evidently connector provides the following Actions:</p> <pre><code> *  CreateProject\n *  CreateFeature\n *  EvaluateFeature\n *  BatchEvaluateFeature\n *  DeleteFeature\n *  DeleteProject\n</code></pre>"},{"location":"guide/reference/amazon/evidently/#example_usage","title":"Example usage","text":"<pre><code>const val USE_REAL_CLIENT = false\n\nfun main() {\n    // we can connect to the real service or the fake (drop in replacement)\n    val http: HttpHandler = if (USE_REAL_CLIENT) JavaHttpClient() else FakeEvidently()\n\n    // create a client\n    val client = Evidently.Http(Region.of(\"us-east-1\"), { AwsCredentials(\"accessKeyId\", \"secretKey\") }, http.debug())\n\n    val projectName = ProjectName.of(\"acme-service\")\n    val featureName = FeatureName.of(\"take-over-the-world\")\n\n    // create project\n    client.createProject(projectName)\n        .onFailure { it.reason.throwIt() }\n\n    // create feature\n    client.createFeature(\n        project = projectName,\n        name = featureName,\n        defaultVariation = VariationName.of(\"bide-our-time\"),\n        variations = mapOf(\n            VariationName.of(\"bide-our-time\") to VariableValue(false),\n            VariationName.of(\"it-is-time\") to VariableValue(true)\n        ),\n        entityOverrides = mapOf(\n            EntityId.of(\"test-subject-1\") to VariationName.of(\"it-is-time\")\n        )\n    ).onFailure { it.reason.throwIt() }\n\n    // evaluate feature\n    val result = client.evaluateFeature(projectName, featureName, EntityId.of(\"test-subject-2\"))\n        .onFailure { it.reason.throwIt() }\n\n    println(result)\n}\n</code></pre> <p>The client APIs utilise the <code>http4k-aws</code> module for request signing, which means no dependencies on the incredibly fat Amazon-SDK JARs. This means this integration is perfect for running Serverless Lambdas where binary size is a performance factor.</p>"},{"location":"guide/reference/amazon/evidently/#default_fake_port_45011","title":"Default Fake port: 45011","text":"<p>To start:</p> <pre><code>FakeEvidently().start()\n</code></pre>"},{"location":"guide/reference/amazon/firehose/","title":"Firehose","text":""},{"location":"guide/reference/amazon/firehose/#installation","title":"Installation","text":"<pre><code>dependencies {\n    implementation(platform(\"org.http4k:http4k-connect-bom:5.22.1.0\"))\n    implementation(\"org.http4k:http4k-connect-amazon-firehose\")\n    implementation(\"org.http4k:http4k-connect-amazon-firehose-fake\")\n}\n</code></pre> <p>The Firehose connector provides the following Actions:      *  CreateDeliveryStream      *  DeleteDeliveryStream      *  ListDeliveryStreams      *  PutRecord      *  PutRecordBatch</p>"},{"location":"guide/reference/amazon/firehose/#example_usage","title":"Example usage","text":"<p>The client APIs utilise the <code>http4k-aws</code> module for request signing, which means no dependencies on the incredibly fat Amazon-SDK JARs. This means this integration is perfect for running Serverless Lambdas where binary size is a performance factor.</p>"},{"location":"guide/reference/amazon/firehose/#default_fake_port_30879","title":"Default Fake port: 30879","text":"<p>To start:</p> <pre><code>FakeFirehose().start()\n</code></pre>"},{"location":"guide/reference/amazon/iamidentitycenter/","title":"IAM Identity Center","text":""},{"location":"guide/reference/amazon/iamidentitycenter/#installation","title":"Installation","text":"<pre><code>dependencies {\n    implementation(platform(\"org.http4k:http4k-connect-bom:5.22.1.0\"))\n    implementation(\"org.http4k:http4k-connect-amazon-iamidentitycenter\")\n    implementation(\"org.http4k:http4k-connect-amazon-iamidentitycenter-fake\")\n}\n</code></pre> <p>The IAMIdentityCenter connector provides the following Fakes:</p>"},{"location":"guide/reference/amazon/iamidentitycenter/#oidc","title":"OIDC","text":"<p>Actions: * RegisterClient * StartDeviceAuthentication * CreateToken</p>"},{"location":"guide/reference/amazon/iamidentitycenter/#default_fake_port_34160","title":"Default Fake port: 34160","text":"<p>To start:</p> <pre><code>FakeOIDC().start()\n</code></pre>"},{"location":"guide/reference/amazon/iamidentitycenter/#sso","title":"SSO","text":"<p>Actions: * SSO: GetFederatedCredentials</p>"},{"location":"guide/reference/amazon/iamidentitycenter/#default_fake_port_25813","title":"Default Fake port: 25813","text":"<p>To start:</p> <pre><code>FakeSSO().start()\n</code></pre>"},{"location":"guide/reference/amazon/iamidentitycenter/#interactive_cli_login","title":"Interactive CLI login","text":"<p>The module provides a CredentialsProvider to do interactive login to</p> <pre><code>val provider = CredentialsProvider.SSO(\n    SSOProfile(\n        AwsAccount.of(\"01234567890\"),\n        RoleName.of(\"hello\"),\n        Region.US_EAST_1,\n        Uri.of(\"http://foobar\"),\n    )\n)\n</code></pre>"},{"location":"guide/reference/amazon/instancemetadata/","title":"Instance Metadata Service","text":""},{"location":"guide/reference/amazon/instancemetadata/#installation","title":"Installation","text":"<pre><code>dependencies {\n    implementation(platform(\"org.http4k:http4k-connect-bom:5.22.1.0\"))\n    implementation(\"org.http4k:http4k-connect-amazon-instancemetadata\")\n    implementation(\"org.http4k:http4k-connect-amazon-instancemetadata-fake\")\n}\n</code></pre> <p>The Instance Metadata Service V1 connector provides the following Actions:</p> <pre><code> *  GetAmiId\n *  GetHostName\n *  GetInstanceIdentityDocument\n *  GetInstanceType\n *  GetLocalHostName\n *  GetLocalIpv4\n *  GetPublicHostName\n *  GetPublicIpv4\n *  GetSecurityCredentials\n *  ListSecurityCredentials\n</code></pre>"},{"location":"guide/reference/amazon/instancemetadata/#example_usage","title":"Example usage","text":"<pre><code>const val USE_REAL_CLIENT = false\n\nfun main() {\n    // we can connect to the real service or the fake (drop in replacement)\n    val http: HttpHandler = if (USE_REAL_CLIENT) JavaHttpClient() else FakeInstanceMetadataService()\n\n    // create a client\n    val client = InstanceMetadataService.Http(http.debug())\n\n    // get local ip address\n    val localIp = client.getLocalIpv4()\n    println(localIp)\n\n    // get identity document\n    val identityDocument = client.getInstanceIdentityDocument()\n    println(identityDocument)\n}\n</code></pre>"},{"location":"guide/reference/amazon/instancemetadata/#credentials_provider","title":"Credentials Provider","text":"<p>The Instance Metadata Service also offers a <code>CredentialsProvider</code>. If the application is running inside an Amazon EC2 environment, this provider can authorize AWS requests using credentials from the instance profile.</p> <pre><code>fun main() {\n    // build a credentials provider that will attempt to load AWS credentials from the EC2's instance profile\n    val credentialsProvider = CredentialsProvider.Ec2InstanceProfile()\n\n    // build a client that will authorize requests with the instance profile credentials\n    val sns = SNS.Http(Region.US_EAST_1, credentialsProvider)\n\n    // send a request\n    val topics = sns.listTopics()\n    println(topics)\n}\n</code></pre> <p>:warning: The <code>Ec2InstanceProfile</code> provider should always be last in the chain, since it will time out if not in an Amazon EC2 environment.</p>"},{"location":"guide/reference/amazon/instancemetadata/#region_provider","title":"Region Provider","text":"<p>The Instance Metadata Service also offers a <code>RegionProvider</code>. If the application is running inside an Amazon EC2 environment, this provider can detect the current AWS region.</p> <pre><code>fun main() {\n    // we can connect to the real service or the fake (drop in replacement)\n    val imdsHttp: HttpHandler = if (USE_REAL_CLIENT) JavaHttpClient() else FakeInstanceMetadataService()\n    val snsHttp: HttpHandler = if (USE_REAL_CLIENT) JavaHttpClient() else FakeSNS()\n\n    /*\n     * Build a RegionProvider chain with the following steps:\n     * 1. Try to get region from AWS_REGION environment variable\n     * 2. Try to get region from profile credentials file\n     * 3. Try to get region from EC2 Instance Metadata Service\n     */\n    val regionProviderChain = RegionProvider.Environment(Environment.ENV) orElse\n        RegionProvider.Profile(Environment.ENV) orElse\n        RegionProvider.Ec2InstanceProfile(imdsHttp)\n\n    // Invoking the chain will return a region if one was found\n    val optionalRegion: Region? = regionProviderChain()\n    println(optionalRegion)\n\n    // orElseThrow will return a region or throw an exception if onr was not found\n    val region: Region = regionProviderChain.orElseThrow()\n    println(region)\n\n    // create and use an Amazon client with the resolved region\n    val sns = SNS.Http(region, { fakeAwsCredentials }, snsHttp)\n    val topics = sns.listTopics()\n    println(topics)\n}\n</code></pre> <p>:warning: The <code>Ec2InstanceProfile</code> provider should always be last in the chain, since it will time out if not in an Amazon EC2 environment.</p>"},{"location":"guide/reference/amazon/instancemetadata/#default_fake_port_63407","title":"Default Fake port: 63407","text":"<p>To start:</p> <pre><code>FakeInstanceMetadataService().start()\n</code></pre>"},{"location":"guide/reference/amazon/kms/","title":"KMS","text":""},{"location":"guide/reference/amazon/kms/#installation","title":"Installation","text":"<pre><code>dependencies {\n    implementation(platform(\"org.http4k:http4k-connect-bom:5.22.1.0\"))\n    implementation(\"org.http4k:http4k-connect-amazon-kms\")\n    implementation(\"org.http4k:http4k-connect-amazon-kms-fake\")\n}\n</code></pre> <p>The KMS connector provides the following Actions:</p> <pre><code> *  CreateKey\n *  DescribeKey\n *  Decrypt\n *  Encrypt\n *  GetPublicKey\n *  ListKeys\n *  ScheduleKeyDeletion\n *  Sign\n *  Verify\n</code></pre>"},{"location":"guide/reference/amazon/kms/#example_usage","title":"Example usage","text":"<pre><code>const val USE_REAL_CLIENT = false\n\nfun main() {\n    // we can connect to the real service or the fake (drop in replacement)\n    val http: HttpHandler = if(USE_REAL_CLIENT) JavaHttpClient() else FakeKMS()\n\n    // create a client\n    val client = KMS.Http(Region.of(\"us-east-1\"), { AwsCredentials(\"accessKeyId\", \"secretKey\") }, http.debug())\n\n    // all operations return a Result monad of the API type\n    val createdKeyResult: Result&lt;KeyCreated, RemoteFailure&gt; = client.createKey(ECC_NIST_P384, ENCRYPT_DECRYPT)\n    val key: KeyCreated = createdKeyResult.valueOrNull()!!\n    println(key)\n\n    // we can encrypt some text...\n    val encrypted: Encrypted = client.encrypt(keyId = key.KeyMetadata.KeyId, Base64Blob.encoded(\"hello\"))\n        .valueOrNull()!!\n    println(encrypted.CiphertextBlob.decoded())\n\n    // and decrypt it again!\n    val decrypted: Decrypted = client.decrypt(keyId = key.KeyMetadata.KeyId, encrypted.CiphertextBlob).valueOrNull()!!\n    println(decrypted.Plaintext.decoded())\n}\n</code></pre> <p>The client APIs utilise the <code>http4k-aws</code> module for request signing, which means no dependencies on the incredibly fat Amazon-SDK JARs. This means this integration is perfect for running Serverless Lambdas where binary size is a performance factor.</p> <p>The FakeKMS implementation currently does not properly encrypt/decrypt or sign/verify the contents of messages - it uses a trivially simple (and fast) reversible algorithm which simulates this functionality.</p>"},{"location":"guide/reference/amazon/kms/#default_fake_port_45302","title":"Default Fake port: 45302","text":"<p>To start:</p> <pre><code>FakeKMS().start()\n</code></pre>"},{"location":"guide/reference/amazon/lambda/","title":"Lambda","text":""},{"location":"guide/reference/amazon/lambda/#installation","title":"Installation","text":"<pre><code>dependencies {\n    implementation(platform(\"org.http4k:http4k-connect-bom:5.22.1.0\"))\n    implementation(\"org.http4k:http4k-connect-amazon-lambda\")\n    implementation(\"org.http4k:http4k-connect-amazon-lambda-fake\")\n}\n</code></pre> <p>The Lambda connector provides the following Actions:</p> <pre><code> *  InvokeFunction\n</code></pre>"},{"location":"guide/reference/amazon/lambda/#example_usage","title":"Example usage","text":"<pre><code>const val USE_REAL_CLIENT = false\n\nfun main() {\n    val deployedLambda = FunctionName(\"http4kLambda\")\n\n    val fakeLambda = FakeLambda(\n        deployedLambda to { req: Request -&gt;\n            val request = Moshi.asA&lt;Req&gt;(req.bodyString())\n            Response(OK)\n                .body(Moshi.asFormatString(Resp(request.value)))\n        }\n    )\n\n    // we can connect to the real service or the fake (drop in replacement)\n    val http: HttpHandler = if (USE_REAL_CLIENT) JavaHttpClient() else fakeLambda\n\n    // create a client\n    val client = Lambda.Http(Region.of(\"us-east-1\"), { AwsCredentials(\"accessKeyId\", \"secretKey\") }, http.debug())\n\n    // all operations return a Result monad of the API type\n    val invokeResult: Result&lt;Resp, RemoteFailure&gt; = client.invokeFunction(deployedLambda, Req(\"hello\"), Moshi)\n    println(invokeResult)\n}\n</code></pre> <p>Note that the http4k-connect Fake Lambda implementation is designed to provide a runtime environment for function HttpHandlers that will be invoked directly using the Lambda URL pattern (<code>https://lambda.${scope.region}.amazonaws.com/2015-03-31/functions/$name/invocations</code>), rather than being deployed behind APIGateway (where you have total control over the URL pattern where the lambda can be invoked).</p> <p>The client APIs utilise the <code>http4k-aws</code> module for request signing, which means no dependencies on the incredibly fat Amazon-SDK JARs. This means this integration is perfect for running Serverless Lambdas where binary size is a performance factor.</p>"},{"location":"guide/reference/amazon/lambda/#default_fake_port_50322","title":"Default Fake port: 50322","text":"<p>To start:</p> <pre><code>FakeLambda().start()\n</code></pre>"},{"location":"guide/reference/amazon/s3/","title":"S3","text":""},{"location":"guide/reference/amazon/s3/#installation","title":"Installation","text":"<pre><code>dependencies {\n    implementation(platform(\"org.http4k:http4k-connect-bom:5.22.1.0\"))\n    implementation(\"org.http4k:http4k-connect-amazon-s3\")\n    implementation(\"org.http4k:http4k-connect-amazon-s3-fake\")\n}\n</code></pre> <p>The S3 connector consists of 2 interfaces:</p> <ul> <li> <p><code>S3</code> for global operations, providing the following Actions:</p> <ul> <li>CreateBucket</li> <li>HeadBucket</li> <li>ListBuckets</li> </ul> </li> <li> <p><code>S3Bucket</code> for bucket level operations, providing the following Actions:</p> <ul> <li>CopyObject</li> <li>CreateObject</li> <li>DeleteBucket</li> <li>DeleteObject</li> <li>DeleteObjectTagging</li> <li>GetObject</li> <li>GetObjectTagging</li> <li>HeadObject</li> <li>ListObjectsV2</li> <li>PutObject</li> <li>PutObjectTagging</li> <li>RestoreObject</li> </ul> </li> </ul>"},{"location":"guide/reference/amazon/s3/#example_usage","title":"Example usage","text":"<pre><code>const val USE_REAL_CLIENT = false\n\nfun main() {\n    // we can connect to the real service or the fake (drop in replacement)\n    val http: HttpHandler = if (USE_REAL_CLIENT) JavaHttpClient() else FakeS3()\n\n    val bucketName = BucketName.of(\"foobar\")\n    val bucketKey = BucketKey.of(\"keyName\")\n    val region = Region.of(\"us-east-1\")\n\n    // create global and bucket level clients\n    val s3 = S3.Http({ AwsCredentials(\"accessKeyId\", \"secretKey\") }, http.debug())\n    val s3Bucket = S3Bucket.Http(bucketName, region, { AwsCredentials(\"accessKeyId\", \"secretKey\") }, http.debug())\n\n    // all operations return a Result monad of the API type\n    val createResult: Result&lt;Unit, RemoteFailure&gt; = s3.createBucket(bucketName, region)\n    createResult.valueOrNull()!!\n\n    // we can store some content in the bucket...\n    val putResult: Result&lt;Unit, RemoteFailure&gt; = s3Bucket.putObject(bucketKey, \"hellothere\".byteInputStream())\n    putResult.valueOrNull()!!\n\n    // and get back the content which we stored\n    val getResult: Result&lt;InputStream?, RemoteFailure&gt; = s3Bucket.get(bucketKey)\n    val content: InputStream = getResult.valueOrNull()!!\n    println(content.reader().readText())\n}\n</code></pre> <p>The client APIs utilise the <code>http4k-aws</code> module for request signing, which means no dependencies on the incredibly fat Amazon-SDK JARs. This means this integration is perfect for running Serverless Lambdas where binary size is a performance factor.</p>"},{"location":"guide/reference/amazon/s3/#how_the_fake_works_with_bucket-level_operations","title":"How the Fake works with bucket-level operations","text":"<p>S3 is a bit of a strange beast in that it each bucket gets its own virtual hostname. This makes running a Fake an interesting challenge without messing around with DNS and hostname files.</p> <p>This implementation supports both global and bucket level operations by inspecting the subdomain of the X-Forwarded-For header, which is populated by the S3 client built into this module.</p> <p>In the case of a missing header (if for instance a non-http4k client attempts to push some data into it without the x-forwarded-for header), it creates a global bucket which is then used to store all of the data for these unknown requests.</p>"},{"location":"guide/reference/amazon/s3/#default_fake_ports","title":"Default Fake ports:","text":"<ul> <li>Global: default port: 26467</li> <li>Bucket: default port: 42628</li> </ul> <pre><code>FakeS3().start()\n</code></pre>"},{"location":"guide/reference/amazon/s3/#connecting_to_a_local_s3_emulator","title":"Connecting to a local S3 emulator","text":"<p>Services like LocalStack or MinIO can emulate AWS services locally. However, for S3 bucket operations you either need to use a specific pre-configured bucket hostname  like <code>http://&lt;bucket-name&gt;.s3.localhost.localstack.cloud:4566</code>, or you configure the <code>S3Bucket</code> to always  perform path-style requests like this:</p> <pre><code>val s3Bucket = S3Bucket.Http(\n    bucketName = bucketName, \n    bucketRegion = region,\n    credentialsProvider = { credentials },\n    overrideEndpoint = Uri.of(\"http://localhost:4566\"),\n    forcePathStyle = true // always use path-style requests\n)\n</code></pre>"},{"location":"guide/reference/amazon/s3/#pre-signed_requests","title":"Pre-Signed Requests","text":"<p>Http4k supports pre-signed requests with the generic <code>AwsRequestPreSigner</code> class. However, <code>http4k-connect</code> provides a simplified interface for common S3 Bucket operations with the <code>S3BucketPresigner</code>.</p> <pre><code>fun main() {    \n    // create pre-signer\n    val preSigner = S3BucketPreSigner(\n        bucketName = BucketName.of(\"foobar\"),\n        region = Region.of(\"us-east-1\"),\n        credentials = AwsCredentials(\"accessKeyId\", \"secretKey\")\n    )\n\n    val key = BucketKey.of(\"keyName\")\n\n    // create a pre-signed PUT\n    val put = preSigner.put(\n        key = key,\n        duration = Duration.ofMinutes(5), // how long the URL is valid for\n        headers = listOf(\"content-type\" to \"application.json\")  // add optional signed headers\n    )\n    println(put.uri)\n\n    // create a pre-signed GET\n    val get = preSigner.get(\n        key = key,\n        duration = Duration.ofMinutes(5)\n    )\n    println(get)\n\n    // share these URIs to your clients so they can perform the operations without credentials\n}\n</code></pre>"},{"location":"guide/reference/amazon/secretsmanager/","title":"Secrets Manager","text":""},{"location":"guide/reference/amazon/secretsmanager/#installation","title":"Installation","text":"<pre><code>dependencies {\n    implementation(platform(\"org.http4k:http4k-connect-bom:5.22.1.0\"))\n    implementation(\"org.http4k:http4k-connect-amazon-secretsmanager\")\n    implementation(\"org.http4k:http4k-connect-amazon-secretsmanager-fake\")\n}\n</code></pre> <p>The Secrets Manager connector provides the following Actions:</p> <pre><code> *  CreateSecret\n *  DeleteSecret\n *  GetSecretValue\n *  ListSecrets\n *  PutSecretValue\n *  UpdateSecret\n</code></pre>"},{"location":"guide/reference/amazon/secretsmanager/#example_usage","title":"Example usage","text":"<pre><code>const val USE_REAL_CLIENT = false\n\nfun main() {\n    // we can connect to the real service or the fake (drop in replacement)\n    val http: HttpHandler = if (USE_REAL_CLIENT) JavaHttpClient() else FakeSecretsManager()\n\n    // create a client\n    val client =\n        SecretsManager.Http(Region.of(\"us-east-1\"), { AwsCredentials(\"accessKeyId\", \"secretKey\") }, http.debug())\n\n    val secretId = SecretId.of(\"a-secret-id\")\n\n    // all operations return a Result monad of the API type\n    val createdSecretResult: Result&lt;CreatedSecret, RemoteFailure&gt; =\n        client.createSecret(secretId.value, UUID.randomUUID(), \"value\")\n    println(createdSecretResult.valueOrNull())\n\n    // get the secret value back\n    println(client.getSecretValue(secretId).valueOrNull())\n}\n</code></pre> <p>The client APIs utilise the <code>http4k-aws</code> module for request signing, which means no dependencies on the incredibly fat Amazon-SDK JARs. This means this integration is perfect for running Serverless Lambdas where binary size is a performance factor.</p>"},{"location":"guide/reference/amazon/secretsmanager/#default_fake_port_58194","title":"Default Fake port: 58194","text":"<p>To start:</p> <pre><code>FakeSecretsManager().start()\n</code></pre>"},{"location":"guide/reference/amazon/ses/","title":"Simple Email Service","text":""},{"location":"guide/reference/amazon/ses/#installation","title":"Installation","text":"<pre><code>dependencies {\n    implementation(platform(\"org.http4k:http4k-connect-bom:5.22.1.0\"))\n    implementation(\"org.http4k:http4k-connect-amazon-ses\")\n    implementation(\"org.http4k:http4k-connect-amazon-ses-fake\")\n}\n</code></pre> <p>The SES connector provides the following Actions:</p> <ul> <li>SendEmail</li> </ul> <p>The client APIs utilise the <code>http4k-aws</code> module for request signing, which means no dependencies on the incredibly fat Amazon-SDK JARs. This means this integration is perfect for running Serverless Lambdas where binary size is a performance factor.</p>"},{"location":"guide/reference/amazon/ses/#example_usage","title":"Example usage","text":""},{"location":"guide/reference/amazon/ses/#default_fake_port_59920","title":"Default Fake port: 59920","text":"<p>To start:</p> <pre><code>FakeSES().start()\n</code></pre>"},{"location":"guide/reference/amazon/sns/","title":"Simple Notification Service","text":""},{"location":"guide/reference/amazon/sns/#installation","title":"Installation","text":"<pre><code>dependencies {\n    implementation(platform(\"org.http4k:http4k-connect-bom:5.22.1.0\"))\n    implementation(\"org.http4k:http4k-connect-amazon-sns\")\n    implementation(\"org.http4k:http4k-connect-amazon-sns-fake\")\n}\n</code></pre> <p>The SNS connector provides the following Actions:</p> <ul> <li>CreateTopic</li> <li>DeleteTopic</li> <li>ListTopics</li> <li>Publish</li> <li>PublishBatch</li> </ul> <p>The client APIs utilise the <code>http4k-aws</code> module for request signing, which means no dependencies on the incredibly fat Amazon-SDK JARs. This means this integration is perfect for running Serverless Lambdas where binary size is a performance factor.</p>"},{"location":"guide/reference/amazon/sns/#example_usage","title":"Example usage","text":""},{"location":"guide/reference/amazon/sns/#default_fake_port_58430","title":"Default Fake port: 58430","text":"<p>To start:</p> <pre><code>FakeSNS().start()\n</code></pre>"},{"location":"guide/reference/amazon/sqs/","title":"Simple Queue Service","text":""},{"location":"guide/reference/amazon/sqs/#installation","title":"Installation","text":"<pre><code>dependencies {\n    implementation(platform(\"org.http4k:http4k-connect-bom:5.22.1.0\"))\n    implementation(\"org.http4k:http4k-connect-amazon-sqs\")\n    implementation(\"org.http4k:http4k-connect-amazon-sqs-fake\")\n}\n</code></pre> <p>The SQS connector provides the following Actions:</p> <pre><code> *  CreateQueue\n *  DeleteMessage\n *  DeleteQueue\n *  GetQueueAttributes\n *  ListQueues\n *  ReceiveMessage\n *  SendMessage\n</code></pre> <p>The client APIs utilise the <code>http4k-aws</code> module for request signing, which means no dependencies on the incredibly fat Amazon-SDK JARs. This means this integration is perfect for running Serverless Lambdas where binary size is a performance factor.</p>"},{"location":"guide/reference/amazon/sqs/#example_usage","title":"Example usage","text":"<pre><code>const val USE_REAL_CLIENT = false\n\nfun main() {\n    val region = Region.of(\"us-east-1\")\n    val queueName = QueueName.of(\"myqueue\")\n    val queueArn = ARN.of(SQS.awsService, region, AwsAccount.of(\"000000001\"), queueName)\n\n    // we can connect to the real service or the fake (drop in replacement)\n    val http: HttpHandler = if (USE_REAL_CLIENT) JavaHttpClient() else FakeSQS()\n\n    // create a client\n    val client = SQS.Http(region, { AwsCredentials(\"accessKeyId\", \"secretKey\") }, http.debug())\n\n    // all operations return a Result monad of the API type\n    val createdQueueResult: Result&lt;CreatedQueue, RemoteFailure&gt; = client.createQueue(queueName, emptyMap(), emptyMap())\n    println(createdQueueResult.valueOrNull()!!)\n\n    // send a message\n    println(client.sendMessage(queueArn, \"hello\"))\n\n    // and receive it..\n    println(client.receiveMessage(queueArn))\n}\n</code></pre> <p>Note that the FakeSQS is only suitable for very simple scenarios (testing and deployment for single consumer only) and does NOT implement real SQS semantics such as VisibilityTimeout or maximum number of retrieved messages (it delivers all undeleted messages to each consumer). Fake SQS queues are, as such, all inherently FIFO queues.</p>"},{"location":"guide/reference/amazon/sqs/#default_fake_port_37391","title":"Default Fake port: 37391","text":"<p>To start:</p> <pre><code>FakeSQS().start()\n</code></pre>"},{"location":"guide/reference/amazon/sts/","title":"Security Token Service","text":""},{"location":"guide/reference/amazon/sts/#installation","title":"Installation","text":"<pre><code>dependencies {\n    implementation(platform(\"org.http4k:http4k-connect-bom:5.22.1.0\"))\n    implementation(\"org.http4k:http4k-connect-amazon-sts\")\n    implementation(\"org.http4k:http4k-connect-amazon-sts-fake\")\n}\n</code></pre> <p>The STS connector provides the following Actions:</p> <pre><code> *  AssumeRole\n *  AssumeRoleWithWebIdentity\n</code></pre> <p>The client APIs utilise the <code>http4k-aws</code> module for request signing, which means no dependencies on the incredibly fat Amazon-SDK JARs. This means this integration is perfect for running Serverless Lambdas where binary size is a performance factor.</p>"},{"location":"guide/reference/amazon/sts/#example_usage","title":"Example usage","text":"<pre><code>const val USE_REAL_CLIENT = false\n\nfun main() {\n    val region = Region.of(\"us-east-1\")\n    val roleArn = ARN.of(\"arn:aws:sts:us-east-1:000000000001:role:myrole\")\n\n    // we can connect to the real service or the fake (drop in replacement)\n    val http: HttpHandler = if (USE_REAL_CLIENT) JavaHttpClient() else FakeSTS()\n\n    // create a client\n    val client = STS.Http(region, { AwsCredentials(\"accessKeyId\", \"secretKey\") }, http.debug())\n\n    // all operations return a Result monad of the API type\n    val assumeRoleResult: Result&lt;AssumedRole, RemoteFailure&gt; = client.assumeRole(roleArn, \"sessionId\")\n    println(assumeRoleResult)\n}\n</code></pre>"},{"location":"guide/reference/amazon/sts/#default_fake_port_20434","title":"Default Fake port: 20434","text":"<p>To start:</p> <pre><code>FakeSTS().start()\n</code></pre>"},{"location":"guide/reference/amazon/systemsmanager/","title":"Systems Manager","text":""},{"location":"guide/reference/amazon/systemsmanager/#installation","title":"Installation","text":"<pre><code>dependencies {\n    implementation(platform(\"org.http4k:http4k-connect-bom:5.22.1.0\"))\n    implementation(\"org.http4k:http4k-connect-amazon-systemsmanager\")\n    implementation(\"org.http4k:http4k-connect-amazon-systemsmanager-fake\")\n}\n</code></pre> <p>The Systems Manager connector provides the following Actions:</p> <pre><code> *  DeleteParameter\n *  GetParameter\n *  PutParameter\n</code></pre>"},{"location":"guide/reference/amazon/systemsmanager/#example_usage","title":"Example usage","text":"<pre><code>const val USE_REAL_CLIENT = false\n\nfun main() {\n    val paramName = SSMParameterName.of(\"name\")\n\n    // we can connect to the real service or the fake (drop in replacement)\n    val http: HttpHandler = if (USE_REAL_CLIENT) JavaHttpClient() else FakeSystemsManager()\n\n    // create a client\n    val client =\n        SystemsManager.Http(Region.of(\"us-east-1\"), { AwsCredentials(\"accessKeyId\", \"secretKey\") }, http.debug())\n\n    // all operations return a Result monad of the API type\n    val putParameterResult: Result&lt;PutParameterResult, RemoteFailure&gt; =\n        client.putParameter(paramName, \"value\", ParameterType.String)\n    println(putParameterResult)\n\n    // get the parameter back again\n    println(client.getParameter(paramName))\n}\n</code></pre> <p>The client APIs utilise the <code>http4k-aws</code> module for request signing, which means no dependencies on the incredibly fat Amazon-SDK JARs. This means this integration is perfect for running Serverless Lambdas where binary size is a performance factor.</p>"},{"location":"guide/reference/amazon/systemsmanager/#default_fake_port_42551","title":"Default Fake port: 42551","text":"<p>To start:</p> <pre><code>FakeSecretsManager().start()\n</code></pre>"},{"location":"guide/reference/example/","title":"Example Service","text":""},{"location":"guide/reference/example/#installation","title":"Installation","text":"<pre><code>dependencies {\n    implementation(platform(\"org.http4k:http4k-connect-bom:5.22.1.0\"))\n    implementation(\"org.http4k:http4k-connect-example\")\n    implementation(\"org.http4k:http4k-connect-example-fake\")\n}\n</code></pre> <p>The Example connector provides the following Actions:</p> <pre><code> *  Echo\n</code></pre>"},{"location":"guide/reference/example/#example_usage","title":"Example usage","text":"<pre><code>const val USE_REAL_CLIENT = false\n\nfun main() {\n    // we can connect to the real service or the fake (drop in replacement)\n    val http: HttpHandler = if (USE_REAL_CLIENT) JavaHttpClient() else FakeExample()\n\n    // create a client\n    val example = Example.Http(http.debug())\n\n    // all operations return a Result monad of the API type\n    val echoedResult: Result&lt;Echoed, RemoteFailure&gt; = example.echo(\"hello\")\n    println(echoedResult)\n}\n</code></pre>"},{"location":"guide/reference/example/#default_fake_port_22375","title":"Default Fake port: 22375","text":"<p>To start:</p> <pre><code>FakeExample().start()\n</code></pre>"},{"location":"guide/reference/github/","title":"GitHub","text":"<p>The GitHub connector currently provides basic action interfaces and support for verifying webhook signatures only.</p>"},{"location":"guide/reference/github/#installation","title":"Installation","text":"<pre><code>dependencies {\n    implementation(platform(\"org.http4k:http4k-connect-bom:5.22.1.0\"))\n    implementation(\"org.http4k:http4k-connect-github\")\n}\n</code></pre>"},{"location":"guide/reference/gitlab/","title":"GitLab","text":"<p>The GitLab connector currently provides basic action interfaces.</p>"},{"location":"guide/reference/gitlab/#installation","title":"Installation","text":""},{"location":"guide/reference/gitlab/#installation_1","title":"Installation","text":"<pre><code>dependencies {\n    implementation(platform(\"org.http4k:http4k-connect-bom:5.22.1.0\"))\n    implementation(\"org.http4k:http4k-connect-gitlab\")\n}\n</code></pre>"},{"location":"guide/reference/google/analytics-ga4/","title":"Google Analytics GA4","text":""},{"location":"guide/reference/google/analytics-ga4/#installation","title":"Installation","text":"<pre><code>dependencies {\n    implementation(platform(\"org.http4k:http4k-connect-bom:5.22.1.0\"))\n    implementation(\"org.http4k:http4k-connect-google-analytics-ga4\")\n    implementation(\"org.http4k:http4k-connect-google-analytics-ga4-fake\")\n}\n</code></pre> <p>The GA connector provides the following Actions:</p> <pre><code> *  PageView\n *  Event\n</code></pre>"},{"location":"guide/reference/google/analytics-ga4/#default_fake_port_35628","title":"Default Fake port: 35628","text":"<p>To start:</p> <pre><code>FakeGoogleAnalytics().start()\n</code></pre>"},{"location":"guide/reference/google/analytics-ua/","title":"Google Analytics UA","text":""},{"location":"guide/reference/google/analytics-ua/#installation","title":"Installation","text":"<pre><code>dependencies {\n    implementation(platform(\"org.http4k:http4k-connect-bom:5.22.1.0\"))\n    implementation(\"org.http4k:http4k-connect-google-analytics-ua\")\n    implementation(\"org.http4k:http4k-connect-google-analytics-ua-fake\")\n}\n</code></pre> <p>The GA connector provides the following Actions:</p> <pre><code> *  PageView\n *  Event\n</code></pre>"},{"location":"guide/reference/google/analytics-ua/#default_fake_port_35628","title":"Default Fake port: 35628","text":"<p>To start:</p> <pre><code>FakeGoogleAnalytics().start()\n</code></pre>"},{"location":"guide/reference/http4k-connect-ksp-generator/","title":"Gradle KSP Plugin","text":"<p>http4k-connect ships with a KSP plugin to automate the generation of the client extension-methods that accompany each Connect client. This allows you to skip creating  those extensions manually and maintain the API of the client appears to contain methods for each Action.</p> <p>See the How-to in the docs for details on how to use this KSP plugin.</p>"},{"location":"guide/reference/kafka/rest/","title":"Kafka Rest Proxy","text":""},{"location":"guide/reference/kafka/rest/#installation","title":"Installation","text":"<pre><code>dependencies {\n    implementation(platform(\"org.http4k:http4k-connect-bom:5.22.1.0\"))\n    implementation(\"org.http4k:http4k-connect-kafka-rest\")\n    implementation(\"org.http4k:http4k-connect-kafka-rest-fake\")\n}\n</code></pre> <p>There are 2 distinct APIs in the Rest proxy:</p>"},{"location":"guide/reference/kafka/rest/#v2","title":"v2","text":"<p>The main <code>KafkaRest</code> connector provides the following v2 Actions:</p> <ul> <li>CreateConsumer</li> <li>DeleteConsumer</li> <li>GetOffsets</li> <li>GetPartitions</li> <li>SeekOffsets</li> <li>CommitOffsets</li> <li>ConsumeRecords</li> <li>ProduceMessages</li> <li>SubscribeToTopics</li> </ul> <p>In addition, you can use a <code>KafkaRestConsumer</code> which provides the following Actions:</p> <ul> <li>ConsumeRecords</li> <li>Delete</li> <li>GetOffsets</li> <li>SeekOffsets</li> <li>CommitOffsets</li> <li>SubscribeToTopics</li> </ul>"},{"location":"guide/reference/kafka/rest/#record_formats","title":"Record formats","text":"<p>The following formats of Kafka records are supported currently. Partition keys are optional and null by default:</p>"},{"location":"guide/reference/kafka/rest/#json","title":"JSON","text":"<p>All keys and messages will be auto-marshalled to JSON using the standard Moshi instance (which supports most common JDK types):</p> <pre><code>Records.Json(listOf(Record(\"123\", \"value\", PartitionId.of(123))))\n</code></pre>"},{"location":"guide/reference/kafka/rest/#avro","title":"AVRO","text":"<p>Support for <code>GenericContainer</code> classes (auto-generated from schema). The Key and Value schemas will be extracted from the Key and Value and sent with the message automatically.</p> <pre><code>Records.Avro(\n    listOf(\n        Record(\n            RandomEvent(UUID.nameUUIDFromBytes(it.toByteArray())),\n            RandomEvent(UUID(0, 0), PartitionId.of(123))\n        )\n    )\n)\n</code></pre>"},{"location":"guide/reference/kafka/rest/#binary","title":"Binary","text":"<p>Record contents are specified using Base64 type for wire transport:</p> <pre><code>Records.Binary(listOf(Record(Base64Blob.encode(\"123\"), Base64Blob.encode(\"456\"), PartitionId.of(123))))\n</code></pre>"},{"location":"guide/reference/kafka/rest/#notes_on_message_production","title":"Notes on message production","text":"<p>Messages can be sent to the broker with or without PartitionIds. If you want to use a strategy for partitioning, the <code>Partitioner</code> interface can be implemented and used as below. <code>RoundRobin</code> and <code>Sticky</code> (key-hash % Partitions) strategies come out of the box.</p> <pre><code>val kafkaRest = KafkaRest.Http(\n    Credentials(\"user\", \"password\"), Uri.of(\"http://restproxy\"), JavaHttpClient()\n)\n\nkafkaRest.produceMessages(Topic.of(\"topic\"), Records.Json(listOf(Record(\"123\", \"\"))), ::RoundRobinRecordPartitioner)\n</code></pre> <p>To keep things simple with respect to partition allocation and rebalancing, the above code will fetch the available partitions on each send to the REST proxy using the <code>/topics/$topic/partitions</code> call. This is obviously not very efficient, but can be reimplemented as needed using any caching strategy which you might wish to implement.</p>"},{"location":"guide/reference/kafka/rest/#v3_confluent_api","title":"v3 (Confluent API)","text":"<p>The main <code>KafkaRest</code> connector provides the following v2 Actions:</p> <ul> <li>GetPartitions</li> <li>GetTopic</li> <li>GetTopics</li> <li>ProduceRecords</li> </ul>"},{"location":"guide/reference/kafka/rest/#record_formats_1","title":"Record formats","text":"<p>The following formats of Kafka records are supported currently. Partition keys are optional and null by default:</p>"},{"location":"guide/reference/kafka/rest/#json_1","title":"JSON","text":"<p>All keys and messages will be auto-marshalled to JSON using the standard Moshi instance (which supports most common JDK types):</p> <pre><code>Record(Json(mapOf(\"key\" to \"value\")))\n</code></pre>"},{"location":"guide/reference/kafka/rest/#binary_1","title":"Binary","text":"<p>Record contents are specified using Base64 type for wire transport:</p> <pre><code>Record(Binary(Base64Blob.encode(\"foo1\")))\n</code></pre>"},{"location":"guide/reference/kafka/rest/#notes_on_message_production_1","title":"Notes on message production","text":"<p>Messages can be sent to the broker with or without PartitionIds. If you want to use a strategy for partitioning, the <code>Partitioner</code> interface can be implemented and used as below. <code>RoundRobin</code> and <code>Sticky</code> (key-hash % Partitions) strategies come out of the box.</p> <pre><code>val kafkaRest = KafkaRest.Http(\n    Credentials(\"user\", \"password\"), Uri.of(\"http://restproxy\"), JavaHttpClient()\n)\n\nkafkaRest.produceRecordsWithPartitions(\n    topic,\n    clusterId,\n    listOf(Record(Binary(Base64Blob.encode(\"foo1\"))),),\n    ::RoundRobinRecordPartitioner\n)\n</code></pre> <p>To keep things simple with respect to partition allocation and rebalancing, the above code will fetch the available partitions on each send to the REST proxy using the <code>/kafka/v3/clusters/$id/topics/$topic/partitions</code> call. This is obviously not very efficient, but can be reimplemented as needed using any caching strategy which you might wish to implement.</p>"},{"location":"guide/reference/kafka/rest/#fake","title":"Fake","text":"<p>The Fake provides the all of the above endpoints listed for v2 and v3, which is enough for basic consumer lifecycle and production and consumption of records. Note that consumers by default will start at the start of the topic stream, although they can be committed to.</p> <p>\"auto.commit.enable\" is enabled by default but can be set to \"false\" for manual committing of offsets.</p>"},{"location":"guide/reference/kafka/rest/#default_fake_port_30091","title":"Default Fake port: 30091","text":"<p>To start:</p> <pre><code>FakeKafkaRest().start()\n</code></pre>"},{"location":"guide/reference/kafka/schemaregistry/","title":"Kafka Schema Registry","text":"<pre><code>dependencies {\n    implementation(platform(\"org.http4k:http4k-connect-bom:5.22.1.0\"))\n    implementation(\"org.http4k:http4k-connect-kafka-schemaregistry\")\n    implementation(\"org.http4k:http4k-connect-kafka-schemaregistry-fake\")\n}\n</code></pre> <p>The main <code>SchemaRegistry</code> connector provides the following Actions:</p> <ul> <li>CheckSchemaRegistered</li> <li>GetSchemaById</li> <li>GetSubjects</li> <li>GetSubjectVersion</li> <li>GetSubjectVersions</li> <li>RegisterSchema</li> </ul>"},{"location":"guide/reference/kafka/schemaregistry/#fake","title":"Fake","text":"<p>The Fake provides the above actions.</p>"},{"location":"guide/reference/kafka/schemaregistry/#default_fake_port_41466","title":"Default Fake port: 41466","text":"<p>To start:</p> <pre><code>FakeSchemaRegistry().start()\n</code></pre>"},{"location":"guide/reference/mattermost/","title":"Mattermost Service","text":"<pre><code>dependencies {\n    implementation(platform(\"org.http4k:http4k-connect-bom:5.22.1.0\"))\n    implementation(\"org.http4k:http4k-connect-mattermost-rest\")\n}\n</code></pre> <p>The Mattermost connector provides the following Actions:</p> <ul> <li>TriggerWebhook</li> </ul>"},{"location":"guide/reference/mattermost/#example_usage","title":"Example usage","text":"<pre><code>const val USE_REAL_CLIENT = false\n\nfun main() {\n    val payloads = Storage.InMemory&lt;List&lt;TriggerWebhookPayload&gt;&gt;()\n\n    // we can connect to the real service or the fake (drop in replacement)\n    val http: HttpHandler = if (USE_REAL_CLIENT) JavaHttpClient() else FakeMattermost(payloads)\n\n    // create a client\n    val mattermost = Mattermost.Http(\n        baseUri = Uri.of(\"https://mattermost.com\"),\n        http = http.debug()\n    )\n\n    val payload = TriggerWebhookPayload(\n        text = \"Hello world\",\n        iconUrl = \"http://icon.url\",\n    )\n\n    // all operations return a Result monad of the API type\n    val result: Result&lt;String, RemoteFailure&gt; = mattermost.triggerWebhook(\n        key = UUID.randomUUID().toString(),\n        payload = payload,\n    )\n    println(result)\n\n    println(payloads)\n}\n</code></pre>"},{"location":"guide/reference/mattermost/#default_fake_port_54786","title":"Default Fake port: 54786","text":"<p>To start:</p> <pre><code>FakeMattermost().start()\n</code></pre>"},{"location":"guide/reference/storage/core/","title":"Storage Core","text":""},{"location":"guide/reference/storage/core/#installation","title":"Installation","text":"<pre><code>dependencies {\n    implementation(platform(\"org.http4k:http4k-connect-bom:5.22.1.0\"))\n    implementation(\"org.http4k:http4k-connect-storage-core\")\n}\n</code></pre> <p>http4k-connect contains a simple lightweight pluggable Key-Value storage abstraction in the <code>http4k-connect-storage-core</code> module, which can be used to serialise objects to an underlying store.</p> <p>Standard Operations are:</p> <ul> <li>Set</li> <li>Get</li> <li>Remove</li> <li>Get all keys with a particular prefix</li> <li>Remove all keys with a particular prefix</li> </ul>"},{"location":"guide/reference/storage/core/#in-memory_storage","title":"In-Memory Storage","text":"<p>All data is held in process memory.</p> <pre><code>data class AnEntity(val name: String)\n\nval storage = Storage.InMemory()\nstorage[\"myKey\"] = AnEntity(\"hello\")\n\nprintln(storage[\"myKey\"])\n\nstorage.removeAll(\"myKey\")\n</code></pre>"},{"location":"guide/reference/storage/core/#on-disk_storage","title":"On-Disk Storage","text":"<p>All data is serialised to disk by passing it though an http4k AutoMarshalling adapter (see the <code>http4k-format-XXX</code> modules). In the example below we use a JSON adapter backed by Moshi (which is the default).</p> <pre><code>import java.io.File\n\ndata class AnEntity(val name: String)\n\nval storage = Storage.Disk(File(\".\"), Moshi)\n\nstorage[\"myKey\"] = AnEntity(\"hello\")\n\nprintln(storage[\"myKey\"])\n\nstorage.removeAll(\"myKey\")\n</code></pre>"},{"location":"guide/reference/storage/http/","title":"HTTP Storage","text":""},{"location":"guide/reference/storage/http/#installation","title":"Installation","text":"<pre><code>dependencies {\n    implementation(platform(\"org.http4k:http4k-connect-bom:5.22.1.0\"))\n    implementation(\"org.http4k:http4k-connect-storage-http\")\n}\n</code></pre> <p>This storage implementation provides the ability to mount another storage implementation remotely over HTTP inside an OpenAPI compatible server.</p> <p>You can mount the storage with: </p> <pre><code>data class AnEntity(val name: String)\n\nval baseStorage = Storage.InMemory&lt;AnEntity&gt;()\nbaseStorage.asHttpHandler().asServer(SunHttp(8000)).start()\n</code></pre> <p>Then simply use your browser to see the OpenAPI specification at http://localhost:8000:</p> <p></p>"},{"location":"guide/reference/storage/jdbc/","title":"JDBC Storage","text":""},{"location":"guide/reference/storage/jdbc/#installation","title":"Installation","text":"<pre><code>dependencies {\n    implementation(platform(\"org.http4k:http4k-connect-bom:5.22.1.0\"))\n    implementation(\"org.http4k:http4k-connect-storage-jdbc\")\n}\n</code></pre> <p>This implementation uses the Jetbrains Exposed library to store the data in the DB. All data is serialised to disk by passing it though an http4k AutoMarshalling adapter (see the <code>http4k-format-XXX</code> modules). In the example below we use a JSON adapter backed by Moshi (which is the default).</p> <pre><code>data class AnEntity(val name: String)\n\nval ds = HikariDataSource(\n    HikariConfig().apply {\n        driverClassName = \"org.h2.Driver\"\n        jdbcUrl = \"jdbc:h2:mem:$name;DB_CLOSE_DELAY=-1\"\n    })\n\n\nval storage = Storage.Jdbc(ds, \"mytable\", Moshi)\nstorage[\"myKey\"] = AnEntity(\"hello\")\n\nprintln(storage[\"myKey\"])\n\nstorage.removeAll(\"myKey\")\n</code></pre>"},{"location":"guide/reference/storage/redis/","title":"Redis Storage","text":""},{"location":"guide/reference/storage/redis/#installation","title":"Installation","text":"<pre><code>dependencies {\n    implementation(platform(\"org.http4k:http4k-connect-bom:5.22.1.0\"))\n    implementation(\"org.http4k:http4k-connect-storage-redis\")\n}\n</code></pre> <p>This implementation uses the Lettuce Client library to store the data in Redis. All data is serialised to disk by passing it though an http4k AutoMarshalling adapter (see the <code>http4k-format-XXX</code> modules). In the example below we use a JSON adapter backed by Moshi (which is the default).</p> <pre><code>data class AnEntity(val name: String)\n\nval storage = Storage.Redis&lt;AnEntity&gt;(Uri.of(\"redis://host:8000\"), Moshi)\n\nstorage[\"myKey\"] = AnEntity(\"hello\")\n\nprintln(storage[\"myKey\"])\n\nstorage.removeAll(\"myKey\")\n</code></pre>"},{"location":"guide/reference/storage/s3/","title":"S3 Storage","text":""},{"location":"guide/reference/storage/s3/#installation","title":"Installation","text":"<pre><code>dependencies {\n    implementation(platform(\"org.http4k:http4k-connect-bom:5.22.1.0\"))\n    implementation(\"org.http4k:http4k-connect-storage-s3\")\n}\n</code></pre> <p>This implementation uses the http4k Connect adapter to store the data in S3. All data is serialised to disk by passing it though an http4k AutoMarshalling adapter (see the <code>http4k-format-XXX</code> modules). In the example below we use a JSON adapter backed by Moshi (which is the default).</p> <pre><code>data class AnEntity(val name: String)\n\nval awsCredentials = AwsCredentials(\"accessKey\", \"secret\")\nval bucketClient = S3Bucket.Http(BucketName.of(\"foobar\"), Region.AP_EAST_1, { awsCredentials }, JavaHttpClient(), Clock.systemUTC())\n\nval storage = Storage.S3(bucketClient, Moshi)\n\nstorage[\"myKey\"] = AnEntity(\"hello\")\n\nprintln(storage[\"myKey\"])\n\nstorage.removeAll(\"myKey\")\n</code></pre>"}]}